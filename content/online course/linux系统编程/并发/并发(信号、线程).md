俄罗斯方块的例子
同步
异步：不知道什么时候到来。到来后的结果不知道。
异步事件的处理：查询法， 通知法。
	江边钓鱼的例子，是每次用渔网自己捞还是看鱼漂的通知。异步事件发生稀疏，发生频率高查询法，养殖场放鱼。火灾事件，传感器。 a date，看手表 定闹钟。过马路，红绿灯。主动与被动。
一、信号
1. 信号的概念
	信号是*软件*中断。
	信号的响应依赖于中断。两者的关系。
	时间片轮转。调度策略。
	中断，硬件的角度。
2. signal();
	原型![[Pasted image 20251027223723.png]]
		给一个信号定义新的行为`sighandler_t`，是否保存旧的行为 返回值。c语言 名空间管理不善。typedef其实没有实现。sighandler_t目前自己抽象出来的。
	1. 命令`kill -l` 查看信号，编号1-31 叫做标准信号，之后sigrtmin-sigrtmax 34-64实时信号。core文件。
	2. `ulimit -a ` core file size ulimit -c 10240
	3. `void(*signal(int signum, void (*func)(int)))(int)`防止了名空间冲突。;
	4. 信号会打断阻塞的系统调用。
3. 信号的不可靠
		以start.c为例，标准信号丢失是一定的。这里说的是信号的行为不可靠。没有人为调用行为。内核帮你布置。
4. 可重入函数
	1. 为了解决信号的不可靠。**第一次调用还没有结束第二次调用就开始了** 重入，像递归不是递归。信号的执行现场由内核来布置。 **所有的系统调用都是可重入的。** 反过来不成立。**一部分库函数也是可重入**的，如：`memcpy`给定源和目的 是不冲突的  rand不可重入，rand_r (reintable #待查)重入。尤其是返回值为指针的。`localtime_r`版本，这个指针所指向的结构体 在静态区上，另外的版本可以用到信号处理当中。
5. **信号的响应过程**
	1. 信号从收到到响应有一个不可避免的延迟。（是因为有中断把当前执行过程打断，压内核即将往外走时才会看到信号 kernel即将回到user态的路上响应的，岔路 打电话）
	2. 思考：如何忽略掉一个信号的？signal函数 ign 实际上把指定的mask位置为0.不能阻止信号的到来，但可以决定信号是否被响应以及在什么时候被响应。
			 标准信号为什么要丢失？
			 标准信号的响应没有严格的顺序。
6. 信号相关的常用函数
	1. kill();
	2. raise();
	3. alarm(); setitimer();//精度控制更好
例：使用单一计时器，利用alarm或setitimer构造一组函数，实现任意数量的计时器. 有了时间观念，机器可以做更多的事情了
	4. pause();
	5. abort();
	6. system();
	7. sleep(); nanosleep usleep select
7. 信号集
     信号集类型：sigset_t  即type
		sigemptyset();
		sigfillset();
		sigaddset();
		sigdelset();
		sigismember();
		

8. 信号屏蔽字/信号pending集的处理
		sigprocmask(); 人为方式控制干扰mask 当前信号状态，mask;信号的到来不知道，信号响应依赖于中断。不能决定信号什么时候到来，能决定信号什么时候被响应。
9. 扩展
	1. sigsuspend(); //wait for signal pause()
	2. sigaction();
	3. setitimer();
10. 实时信号

二、多线程