## kill
**发信号**
,而多半的信号的功能是终止。
`int kill(pid_t pid,int sig)`
### pid
wait函数中也有一个pid参数。
- pid 为正数
- pid=0,sig发送给和当前进程同组的所有进程。组内广播。
- pid=-1 指定的sig发送给当前进程有权限发送信号的所有进程，除了1号，)全局广播.init会发，关机时。
- pid<-1时，sig发送给所有进程组id为 -pid。负负得正。


### sig
- sig =0 没有信号发出，error check。 被用于检测一个进程（组）是否存在。

### 返回值
-1返回值为-1,不一定不存在，看errno,如果返回的时eperm说明没有权限。真错假错。

## raise
> send a signal to the caller

自己给自己发。`int raise(int sig)`=``kill(getpid(),sig)
在多线程中`pthread_(pthread_self(),sig)`一个以进程为单位，一个以线程为单位。
什么时候给自己发送信号？


杀掉进程得到coredump文件。

## alarm()
> 里程碑式，可以做很多事情。

`unsigned int alarm(unsigned int seconds);`倒计时结束后，发送信号。以秒为单位计时，alarm默认动作 杀掉进程。
信号的响应有时间延迟。
```c alarm.c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main()
{
	alarm(5);
	while(1);
	
	exit(0);
}
```

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main()
{
	alarm(10);
	alarm(1);
	alarm(5);
	while(1);
	
	exit(0);
}
```
5秒杀死。是sleep(alarm+pause来封装的)的问题。
## pause()
> wait for signal

人为的阻塞系统调用。
```c

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main()
{
	alarm(10);
	alarm(1);
	alarm(5);
	while(1)
		pause();
		
	exit(0);
}
```

- 定时循环

```c 5sec.c
#include<stdion.h>
#include<stblib.h>
#include<time.h>

int main()
{

	time_t end;
	int64_t count=0; //64防止溢出
	
	end = time(NULL)+5; //time获取当前时戳，终止时间
	while(time(NULL)<= end)
		count++; //在五秒钟之内
	printf("%lld\n",count);

}
```

- `time ./5sec >tmp/out`![[Pasted image 20251029203431.png]]

```c 5sec_signal.c
#include<stdio.h>
#include<stdlib.h>
static int loop=1;
static void alrm_handler(int s)
{
	loop=0;	 //异步事件。
}
int main()
{
	int64_t count=0;
	alarm(5);
	signal(SIGALRM,alrm_handler);
	while(loop)
		count++;
	printf("%lld\n",count);
	exit(0);
}

```
![[Pasted image 20251029204016.png]]


- volatile 的作用 gcc 优化会成永真循环。loop永远为真。
- 信号和time 不同精度。

---
mycat dfd改为1 argc 2 读源数据写到终端。