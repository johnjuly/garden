
筛质数的例子 201个进程。用指定n个进程筛质数。

`cp ../../process_basic/primer0.c  ./`放到当前路径下

现在的计算范围，thrnum :right-left右边界-左边界![[Pasted image 20251203221905.png]]



- 思路：main当中，一个人干活 计算，现在希望每有一个待计算的i值用一个线程去做 for循环里的工作 用一个函数。main创建线程 兄弟 没有主次之分。
```c
int main()
{
	int i,err;
	pthread_t tid[THRNUM]; //需要的参数 create
	for(i=LEFT;i<=RIGHT;i++)
	{
		err=pthread_create(&tid+(i-LEFT),NULL,thr_prime,&i);
		if(err)
		{
			fprintf(stderr,"pthread_create():%s\n",stderror(err));
			exit(1);  //join 收尸 如果 最后一个线程失败 需要将前面的回收资源
		}
	}
	
	//收尸
	for(i=LEFT;i<=RIGHT;i++)
		pthread_join(tid[i-LEFT],NULL);

	exit(0);
}

static void *thr_prime(void *p)
{
	int i,j,mark;
	i = *(int *)p;
	mark=1;
	//是质数的话输出 不是的话算了
	for(j=2; j<i/2;j++)
	{
		if(i%j == 0)
		{
			mark=0;
			break;
		}
	}
	if(mark)
		printf("%d is a primer\n",i);
	pthread_exit(NULL);
}


```

![[Pasted image 20251203223231.png]]
出现竞争 ，非原子操作。
协议 大家的约定。
十字路口 没有红绿灯，两辆车 南北 东西方向 
车什么时候到来不知道 异步事件 什么
竞争：在没有约定的情况下 大家在抢同一个资源在用。十字路口 资源 两辆车 不知道是否相撞 无法预料。如何让两辆车不相撞？
最好不要用sleep 无法解决两个问题 等什么 等多久； 哲学问题
那如何让两辆车相撞？加长车长度，sleep 调试手段让线程存在时间增长 等待 测试 。 

`ps ax -L`

错误：地址传参，i 一块地址 用201个指针指向这一块空间
201个人在用同一个地址 
传值 可以 丑陋的办法 强转 void* i

看是否有各种形式的退出。
并发：顺序不是 从小到大

`./primer0 |wc -l`

---
继续改进：不要强转
201个i在201个空间
捏一个结构体
考虑动态分配
传结构体类型指针
```c primer0_e.c

struct thr_arg_st
{
	int n;
};


for
struct thr_arg_st *p;

p=malloc(sizeof(*p));
if(p==NULL)
{
	perror("malloc()");
	exit(1);
}
p->n=i;
err=pthread_create(tid+(i-LEFT),NULL,thr_prime,p); 


```


```c
i = (struct thr_arg_st*)p->n;
free(p);
```

但这样做也不好，希望malloc和free在用一个函数当中 或者同一个模块

改 pthread_join pthread_exit 传p

```c
void *ptr;
for(i=LEFT;i<=RIGHT;i++)
{
	pthread_join(tid[i-LEFT],&ptr);
	free(ptr)
}


---

pthread_exit(p);
```


一个进程中能够创建出的线程个数？
一个函数扔出去很多次，代码段公用 栈独立
ulimt -a 栈 大小![[Pasted image 20251203230244.png]]
虚拟空间大小，需要看当前空间里可以创建多少10m的栈。取决于外在的资源量。64位 是tid先 消耗掉。128t

资源数 有上限。