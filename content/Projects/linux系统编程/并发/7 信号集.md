---
created: '2026-01-06'
---

`man sigemptyset` 集合。囊括标准集合信号的个数。sigset_t 位图的形式。
emptyset
fillset全集 包含所有信号。
sigaddset
sigdelset
sigismember 判断。

---

`(int how,const sigset_t *set,sigset_t *oldset) ;`做how 的操作。 
返回值。
```c block.c

#include <signal.h>

static void int_handler(int s)
{
	write(1,"!",1);
}
int main()
{

	int i;
	//signal(SIGINT,SIG_IGN); //忽略
	signal(SIGINT,int_handler);//指定响应方式
	//往屏幕打印信号 1s打印一个
	for(i=0;i<10;i++)
	{
		write(1,"*",1);
		sleep(1);
	}
	
	exit(0);
}
```


每秒打印一个星号。ctrl+c 会响应打印一个叹号，但多个ctrl+c会打断当前阻塞的系统调用。
改动：
```c
for(j=0;j<1000;j++)
{
	for(i=0;i<5;i++)
	{
		write(1,"*",1);
		sleep(1);
	}
	write(1,"\n",1);
}
```

内部循环每秒打印一个星号 打印五个之后换行开始打印下一行。

ctrl+\ sigquit快捷方式
实现的功能： 在两行之间响应星号。阻塞信号。之后再响应。
先把信号放到集合当中去，在代码执行之前首先把所有集合block住，即把集合中信号的mask位置为0.屏蔽阻塞，接触阻塞。
```c
sigset_t set;
sigemptyset(&set)
sigaddset(&set,SIGINT);//这个集合中只有这么一个信号存在
for(j=0;j<1000;j++)
{
	sigprocmask(SIG_BLOCK,&set,NULL);
	for(i=0;i<5;i++)
	{
		write(1,"*",1);
		sleep(1);
	}
	write(1,"\n",1);
	sigprocmask(SIG_UNBLOCK,&set,NULL);
}
```

![[Pasted image 20251108213930.png]]多个信号只有一个响应，反映到Pending 是位图。标准信号的丢失。
宏观编程的意识：大规模中的小函数。解除了阻塞。确定进入退出这个模块全局状态不会改变。保存恢复工作。
```c
sigset_t saveset;
sigprocmask(SIG_UNBLOCK,&set,&saveset);


//end
sigprockmask(SIG_SETMASK,&saveset,NULL);
```
setmask
```c
sigset_t set,oset;
sigemptyset(&set)
sigaddset(&set,SIGINT);//这个集合中只有这么一个信号存在
for(j=0;j<1000;j++)
{
	
	sigprocmask(SIG_BLOCK,&set,&oset);
	for(i=0;i<5;i++)
	{
		write(1,"*",1);
		sleep(1);
	}
	write(1,"\n",1);
	sigprocmask(SIG_SETMASK,&oset,NULL);
}
```
阻塞->保存之前的状态->恢复之前的状态
