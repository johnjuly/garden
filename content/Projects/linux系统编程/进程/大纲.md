---
created: '2026-01-06'
---

#todo   

执行一次返回两次

  

a当中实现跳转点。

```c

static jmp_buf save;

//全局变量

  

a()

{

int ret;

ret=setjmp(save);

if(ret == 0)

{

printf("%s():Call b().\n",__FUNCTION__);

b();

printf("%s():b() returned.\n",__FUNCFTION__);

}

else

{

printf("%s():JUmped back here with code %d\n",__FUCNTION__,ret);//从别处跳回来的

}

}

  

```

  

d中实现longjmp

  

```c

d()

{

printf("%s():Begin");

printf("%s():Jump now!"，__FUNCTION__);//预备跳

longjump(save,6);

}

```

直接从函数d跳到了函数a，跨函数安全跳转。longjump带回去一个0的话，会把1带回来。看手册。

  
  

8. 资源的获取及控制

  
  

`ulimit -a`

一个进程能使用的资源量。open files 一个进程能够打开的最多文件数量1024。存放描述符的数组。ulimit -n 数字 改数值

查看获取/设置/改变

  
  

`getrlimit():`

`setrlimit();`

他们封装产生Ulimit

  
  

硬限制标杆，软限制可以在硬限制下浮动。普通用户对于硬限制只能下降不能拉高。root可升高。![[Pasted image 20251012183550.png]]

  
  

# 进程的基本知识

  
  

已经进入多进程阶段，

  
  

1、进程标识符pid

类型 `pid_t`：有符号16位整型数，三万多进程？虚拟机计数

命令ps(process snapshot),常用ps axf/axm/ax -L(包括LWP轻量级)

进程号是顺次向下使用，不是优先使用当前范围内最小的，与fd不同。

getpid();

getppid();//父进程

2、进程的产生，重要函数

fork();执行一次，返回两次。
[[fork 实例]]
注意理解关键字:duplicating,意味着拷贝 克隆 一摸一样等含义

fork后父子进程区别:fork的返回值不一样，pid，ppid不同。未决信号和文件锁不继承。资源利用量归0。

create a child process。子进程连父进程的执行位置也一样

init进程:1号，是所有进程的祖先进程[[init 进程 vfork]]
调度器的调度策略来决定哪个进程先运行，如果想让子进程先运行，让父`sleep(1)`;fflush的重要性

vfork();

3、进程的消亡及（收尸）释放资源

wait() man 2 系统调用
> 等待进程状态发生变化 change state;`pid_t wait(int *status)`状态的位置
	各种宏；涉及到的退出码status 使用宏进行检测；如果是正常结束，进一步确定退出码是多少；如果是被信号打断的，进一步确定信号值是多少，还可用coredump检测；嵌套使用

看 return 值
上一个死等。阻塞。
`waitpid(pid_t pid，int *status,int options)`;waitpid好用的地方在于第三个参数，位图，按位或；WNOHANG，非阻塞。白发人送黑发人。。。创建出来的资源。
进程分组，大家都退出。用户分组，统一权限更改。统一操作。 ![[Pasted image 20251017233631.png]] #todo
wait :waitpid(-1,&status,0)的封装![[Pasted image 20251017234007.png]]
201->201
1. 分块 201->N 201个计算用N个进程来算。
![[Pasted image 20251018142452.png]]
1号负载最重，三号计算数大。3碰到的质数少。质数的计算方法，从2到数据的一半。
2. 交叉分配，有一定随机性。也不是很好，这里。一般是好的。在这个模型里1号每次都拿到3的倍数。![[Pasted image 20251018142729.png]]
3.  池。上游的任务，下游三个进程抢任务。能者多劳，拿到了质数/非质数，谁先算完谁抢![[Pasted image 20251018143001.png]]


4、exec函数族
为什么shell子进程是primer而不是shell
  execl();
  execlp();
  execle();
  execv();
  exevp()
  注意fflush的使用

5、用户权限及组权限

  

6、观摩课:解释器文件

  

7、system();

  

8、进程会计|非重点

  

9、进程时间

  

10、守护进程
> 精灵进程

/服务 在后台跑。httpd服务。上网。dhcp。动态分配Ip地址。ssh服务。所用服务的server。
资源管理器，windows。刚开机就启动。

满足的条件：一般情况下脱离控制终端 输入输出不影响；会话，group的leader。 qq 服务器。不是等你需要时才启动。/
![[Pasted image 20251025145446.png]]上一次的图 #todo
会话 session，标识sid
终端
setsid():实现守护进程
getpgrp();
getpgid();
setpgid();
单实例 唯一 守护进程：锁文件 /var/run/name.pid 把当前的pid写进去
启动脚本文件： /etc/rc*...
11、系统日志
syslogd服务，要提交的内容交给它，只有它有权限写系统日志，权限分离。 
openlog(); //关联
syslog();
closelog();