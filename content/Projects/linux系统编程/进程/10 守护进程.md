---
created: '2026-01-06'
---


一个命令产生两个进程`ls|move`.前台进程组后台进程组。
前台最多有1个。![[Pasted image 20251025145954.png]]


- `setsid()` :creates a new session if the calling process is not a process group leader。有条件的创建。一个进程产生子进程，父进程天生是group leader。后面的就是守护进程的特点。no controlling tty,脱离控制终端，为?号。seesion的leader，group的Leader。满足的特点ppid为1,其余三项相同，tty为问号。父进程退出，不需要等待。![[Pasted image 20251025150724.png]]
- 
- `ps axj`

---

```c mydaemon.c
#include <stdio.h>
#include<stdlib.h>
//其他的头文件

#define FNAME "/tmp/out"


static int daemonize(void)
{
	int fd;
	pid=fork();
	if(pid<0)
	{
		perror("fork()");
		return -1;
	}
	if(pid>0)
	{
		exit(0); //父进程正常结束
	}
	//铺垫性的工作，将来需要脱离控制终端，012三个文件描述符没有必要关联设备。
	fd=open("/dev/null",O_RDWR);
	if(fd<0)
	{
		perror("open()");
		return -1;
	}
	
	dup2(fd,0);
	dup2(fd,1);
	dup2(fd,2);
	if(fd>2)
		close(fd);
		//父进程变成1号Init
	setsid(); //最主要的目的。子进程调用

	chdir("/");
	//umask(0);
	
	return 0;
}

int main()
{
	FILE *fp;
	if(daemonize())
		exit(1);//如果失败了，走 结束
	
	fp=fopen(FNAME,"w");

	if(fp ==NULL)
	{ 
		perror("fopen()");
		exit(1);
	}
	
	for(i=0; ; i++)
	{
		fprintf(fp,"%d\n",i);
		fflush(fp); //行缓冲，而文件全缓冲模式
		sleep(1);
	}
	exit(0);
}


```

- 守护进程的作用：持续写文件 每秒中往文件中写一个字符![[Pasted image 20251025153626.png]]
- 使用命令`tail -f /tmp/out`
- `kill pid`杀死是守护进程
- 标准出错 应该不往标准输出上走，需要标准日志的写法