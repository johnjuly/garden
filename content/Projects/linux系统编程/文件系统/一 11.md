---
created: '2026-01-06'
---



- main的参数跟命令行解析通配符
```c main.c
#include <stdio.h>

#include<stdlib.h>

int main(int argc,char *argv[])
{
	printf("argc=%d\n",argc);
	
	exit(0);
}

```


- `./main hello world`
- `./main *.c`
- `{c}  int glob(const char*pattern  ,int flags,int(*errfunc)(const char *epath,int errno),glob_t *pglob);`
- `{c} void globfree(glob_t *pglob);`
- GLOB_NOSORT提高局部效率问题；函数参数第一个模式，第二个常用要求，第三个一个指向函数的指针。保存出错路径与原因。第四个参数 结果存放位置。


要解析的pattern,解析到哪个路径失败了，可以打印;glob解析目录文件下的*不包含隐藏文件 `.*`包含隐藏文件。
```c
#include<glob.h>

#if 0
#define PAT "/etc/a*.conf" 

int errfunc_(const char *erpath,int errno)
{
	puts(errpath);
	fprintf(stderr,"ERROR MSG:%s\n",strerror(error));
}

#endif

int main()
{
	gob_t globres;
	int err;
	err=glob(PAT,0,NULL,&globres);
	if(err)
	{
		printf("Error code = "%d\n",err);
		exit(1);
	}
	
	for(int i=0;i<globres.gl_pathc;i++)
		puts(globres.gl_pathv[i])；
		
	glob_free(&globres);
			
	exit(0);
}


```

- ls -a =./*  ./.*



得到所有文件,当前目录当成目录流
```c
#include<dirent.h>
#define PAT "/etc"

int main()
{
	DIR *dp;
	struct dirent *cur;
	
	dp = opendir(PAT);
	if(dp == NULL)
	{
		perro("opendir()");
		exit(1);
	}
	
	while((cur = readdir(dp))!=NULL)
	{
	
	puts(cur->d_name);
	}	
	
	closedir(dp);
	
	exit(0);

}



```



解析目录结构


`du`:显示当前路径所占磁盘空间大小 k为单位,可以跟多个文件；用stat看block数除以2为k;

会用到递归：目录文件，非目录文件

```c  mydu.c
#define PATHSIZE 1024
//longlong

static int path_noloop(const char *path)
{
	char *pos;
	
	pos=strrchr(path,'/');//最右边
	if(pos==NULL)
		exit(1);
	if(strcmp(pos+1,".") == 0||strcmp(pos+1,"..") == 0)
		return 0;
	return 1;
	
}
static int64_t mydu(const char *path)
{
	//path为非目录文件
	//return st_blocks/2;
	//path为目录文件，path/*与 path/.*(隐藏文件)掉用glob解析；stat;
	
	//判断 获得文件属性 不用state符号连接会展开
	struct stat statres;
	char nextpath[PATHSIZE]；
	glob_t globres;
	int64_t sum
	if(lstat(path,&statres)<0)
	{
		perror("lstate");
		exit(1);
	}
	//宏与位图两种方式 mode
	if(!S_ISDIR(statres.st_mode))
		return statres.st_blocks;
	
	strncpy(nextpath,path,PATHSIZE);
	strncat(nextpath,"/*",PATHSIZE);//追加，整体长度不超过PATHSIZE
	//解析
	glob(nextpath,0,NULL,&globres);//iferr
	/*for()
		mydu();*/
	
	strncpy(nextpath,path,PATHSIZE);
	strncat(nextpath,"/.*",PATHSIZE);//构成回路 .指向自己；..指向父级
	glob(nextpath,GLOB_APPEND,NULL,&globres);//追加append
	//sum=0;
	sum=statres.st_blocks;
	
	for(i=0;i<globres.gl_pathc;i++)
	//有一个条件判断 不是自己和父级才去调用
	{
		if(path_noloop(globres.gl_pathv[i]))
			sum+=mydu(globres.gl_pathv[i]);
	}
	//当前文件
	//sum+=statres.st_blocks;
	globfree(&globres);
	return sum;
	
	
	

}




int main(int argc,char **argv)
{
	if(argc<2)
	{
		fprintf(stderr,"Usage...");
		exit(1);
	}
	
	printf("%lld\n",mydu(argv[1]/2));
}

```

优化 静态区 static