## 乱序执行
out of order execution.
- 也称为指令动态调度：由硬件在运行时完成
- 简单描述
	- 指令译码完成后，放入保留站 （指令缓存空间）
	- 每个周期，检测保留站中每条指令的源操作数
	- 如果指令的源操作数都准备好了，发送指令到执行单元（如果有空闲）
	- 指令完成后，从保留站删除
- 好处
	- 当某条指令的执行时间很长时，允许后面的不相关指令先执行
	- 有相关性的指令给无相关性的指令让路
- 条件
	- 需要为数据的生产和消费方建立关联关系 ：寄存器重命名，每个数据都和一个tag关联
	- 需要缓存那些操作数还没有准备好的指令：放到保留站
	- 指令需要检测其操作数状态（是否准备好）：当数据准备好时，会广播其tag;所有指令将其tag与广播的tag进行比较，如果相同，表明数据准备好；
	- 当所有数据都准备好时，需要将指令发送到执行单元：所有操作数都准备好时，指令会被唤醒；如果多条指令同时被唤醒，需要选择一条发送到执行单元
### Tomasulo 算法
-  **核心思想**
	- 每个计算单元维护一个保留站（一组物理寄存器）：用于缓存操作数还没有准备好的指令
	- 通过寄存器**重命名消除WAW and WAR相关性** ：将寄存器ID重命名为保留站ID
	- 乱序发送指令
- 硬件结构：
	- 保留站
	- 寄存器组 
	- Bus 广播结果  带上提供该结果的保留站ID
### 精确异常
 当异常发生时，异常之前的指令应该执行完，异常之后的指令不应该执行。
 非精确异常：乱序执行，后面的指令比前面的指令先执行完，修改了系统状态（寄存器或者内存） ：Tomasulo算法不能保证精确异常
- 乱序执行如何保证精确异常？
	- 思路：**利用缓存(ROB)临时记录执行结果，等到前面所有指令提交(commit 阶段)之后，再提交该指令结果**。
	- 总结：**乱序执行，但顺序提交。**


### Reorder Buffer
每一项内容：目标寄存器ID、指令结果、指令op
- 指令进入保留站的同时，也进入ROB (两个cache
- 寄存器ID重命名为ROB ID ，不是保留站ID
- 指令在写回阶段将结果写入ROB，而不是寄存器/内存 后面的指令可以从ROB读取这些结果
- 当指令commit 才将结果写到寄存器/内存，commit后 将指令从ROB删除

只要指令尚未commit 就不会修改系统状态，这样就很容易取消指令（比如遇到异常）


### 带ROB的乱序执行 总结
- Issue:发送指令到保留站 （若保留站和ROB都空余），用一个ROB表项存储结果；读操作数 检查是否READY
- Execute: 若所有操作数都已经准备好，执行指令；否则监听总线，若发现操作数就读取 并保存在保留站
- write back:发送结果到总线，释放保留站表项；ROB更新结果
- Commit:若前面指令都已将commit,且没有发生异常，将结果从ROB写入register/memory,释放ROB表项；若发生异常 清空指令列表和ROB等