
# 章节2：进程

>  对象基类的名字 可以看作

## 并发

- 保存：
	- 状态 无状态的cpu
	- 寄存器 保存

- notepad应用程序 windows/system32

| 程序  | 进程        |
| --- | --------- |
| 静态  | 静态        |
| 一   | 对多 打开多个窗口 |

## 数据结构 PCB[^1]

[^1]: 数字电路中指的是可印刷电路 数据结构中另有所指 #待查
- context 结构体  寄存器 的值 存储状态
- 如何管理？当不知道数据的数量时？**链表**管理对象，打开与关闭 摘下
- 单链表还是双链表？ 链表的删除操作 ，要删5,要找到4指针；双链表更好操作？
- 存档与读档
？

## 进程切换


- sleep做两件事：外设 硬件时钟timer定时器；保存现场
- 核心函数 switch_to,两个参数：停下来的 与即将接管的context地址
- 参数放在a0,a1寄存器。同样顺序保存
- `{asm}  j ra`: 返回地址也会 存档 ，读档的时候也会读返回地址，最终返回的是to的返回地址 当我只看context_switch时p0 的ra时

| c语言  | 汇编              |
| ---- | --------------- |
| 函数返回 | 修改pc位置 没有函数没有返回 |

## 进程的设计目标

- 设计的角度是否想要switch_to
- 在正确的时刻让步cpu 
	- 什么时候临时不用cpu(使用其他设备)
	- 调用封装好的函数使用外部设备。包含switch_to
	- 若想写自己的prinf指令函数 ，不行，需要特权态，用户态想调用特权态，通过请求操作系统帮助（syscall，嵌入switch_to函数），
	- 特权回收 cve
- 如何选择需要cpu的进程？
	- 分类管理
	- 有限状态机：3个状态：running waiting ready
	>  划分进程状态 以确定运行谁
	>  
	- nice系统调用 主动放弃cpu 到ready状态
	- 定时器 打点 打断 中断 正在运行的cpu放到ready.交错使用cpu。公平运行的机会在大型机可行 个人pc不太可行
	- running 状态只有一个
	- 内核将相同状态进程pcb放在同一链表中；一共2个链表
	- 可以缩短waiting长度n ，增加条数 ，选择一个对象O(n)
	- 如何减少时间复杂度ready链表找      O(1)调度器
	- 等待/就绪队列太长，转到挂起状态，内存不够用，剥夺内存资源 ，放到外存
	- 挂起状态队列，与其他队列不同点 需要将数据写到磁盘中。笔记本电脑盖合上，读写磁盘
	- linux五状态，windows七状态
### 进程调度不是免费的 
	人与朋友的比喻 ，cpu 与其他打交道的设备 内存 硬盘 网络
- cisc risv 不同体系结构上下文切换，risv寄存器更多，上下文保存和恢复更多 ，
- arm 加入 内存操作 把一串寄存器全部加载，类似于网络中 第一次握手 传很多数据 接下来的数据不用再握手 批量 不是一个一个往里存
- ![[Pasted image 20250916151832.png]]
- 设计 系统 芯片 也需要考虑用户


## 调度算法

- 概念：抢占式与非抢占式
- 客机飞行控制系统 探月系统  -> 不可抢占


### 设计目标（尺子）
- 对于服务器管理员：处理器利用率最大化
- 对于服务器用户： 更好的交互性
- 两者不对等
### 指标
- cpu使用率
- 吞吐量
- 周转时间
- 等待时间

#### 高吞吐 低延迟
- 从老校区到新校区
- 班车与打车
- 都可以描述为快
- 马路上的救护车
- 对数据进不进行低延迟标记。网络标记数据包 是否 紧急传递
#### 响应时间







