---
title: "进程和线程（网络视频笔记）"
tags:
  - 操作系统
  - 复习
  - 网络视频
  - 进程
  - 线程
---

相关：[[../课堂整理/0916 进程]] / [[../课堂整理/1104 多进程 线程]]


维护的程序的执行过程
## 进程的概念
### 进程的定义
> [! definition]
> 进程是指具有一定独立功能的程序在一个**数据集合**上的一次**动态执行**过程。两个特征 ，程序+数据+动态执行



进程和程序之间的变化。操作系统如何维护？内存中堆栈，加入函数地址。

### 进程的组成
> 包含了正在运行的一个程序的**所有状态**的信息

代码；数据；
进程控制块
状态寄存器 : cpu状态CR0,指令指针IP
通用寄存器：ax,bx,cx
进程占用系统资源：打开文件、已分配内存

### 进程的特征
- 动态性 创建到结束
- 并发性 交替执行多个程序；进程可以被独立调度并占用cpu运行
- 独立性：不同进程的工作不影响
- 制约性：因访问共享数据/资源或进程间同步而产生制约；独立与制约的权衡；
cpu上 的一个指令指针，指针切换，

### 进程与程序的联系
- 进程是操作系统处于执行状态程序的抽象
	- 程序=文件 静态 可执行
	- 进程=执行中的程序=程序+执行状态
- 同一个程序的多次执行过程对应不同进程
	- 命令`ls`的多次执行对应多个进程
- 进程执行需要的资源
	- 内存：保存代码和数据
	- CPU: 执行指令
### 进程与程序的区别
- 一静 一 动
- 一暂时（开始到结束） 一永久
- 组成不同，包括程序、数据和进程控制块


##  进程控制块 

操作系统控制和管理进程运行的过程

> 操作系统管理控制进程运行所用的信息集合

- 操作系统用PCB来描述进程的基本情况 id,执行的程序 以及运行变化的过程，状态
- **PCB是进程存在的唯一标识**

### 进程控制块的使用
进程创建：生成该进程的PCB
进程终止：回收它的PCB
进程的组织管理：通过对PCB的组织管理来实现
PCB包含的具体信息？如何组织？进程的状态转换？


### **内容**:

pc,sp:函数调用会返回，当时的栈顶在什么地方
#### 标识信息
id
#### cpu 现场保存 ,为交替使用
其他寄存器
#### 进程控制信息
- 调度和状态信息：调度进程和cpu使用情况
- 进程间通信信息：（与外界打交道，读数据，处理不同数据）进程间通信相关的各种标识
- 存储管理信息：指向进程映像存储空间数据结构
- 进程所用资源：进程使用的系统资源，如打开文件等 最后是要回收的
- 有关数据结构连接信息：与PCB相关的进程队列

### 进程数据块的组织
链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表：就绪、阻塞
索引表：同一状态的进程归入一个索引表，由索引指向PCB


## 进程的状态

生命周期：
创建-执行-等待-抢占-唤醒-结束


### 进程创建
- 系统初始化，创建第一个用户进程
- 用户进程，用户请求创建一个新进程-> 就绪
- 正在运行的进程执行了创建进程的系统调用
### 进程执行
就绪队列->运行
内核选择一个就绪的进程，让它占用处理机并执行？
如何选择？处理器的调度算法

### 进程等待（阻塞）
- 请求并等待系统服务，无法马上完成
- 启动某种操作，读写磁盘，无法马上完成
- 需要的数据没有到达
只有进程自身才能知道何时需要等待某种事件的发生，内部原因导致进入等待状态

### 抢占
高优先级进程就绪
进程执行当前时间用完，时间片起到的作用

### 被唤醒
进入等待条件的反过来
等待的事件出现，等待的资源被满足

同样，与等待进入相反，进程只能被别的进程或操作系统唤醒，不是自身原因

### 结束
退出，占用的资源还给操作系统

正常退出；错误退出；（自愿）||致命错误；被其他进程所杀；（强制）


### 例子
sleep()系统的调用对应的进程状态变化


## 三状态进程模型

核心状态 
- 运行（Running）:进程正在处理机上执行
- 就绪（Ready）进程获取了除处理机以外的资源
- 等待 阻塞（Blocked）进程正在等待某一事件的出现而暂停运行
辅助状态
- 创建(new) 过渡状态，一个进程正在被创建，分配资源和数据结构初始化，还没转到就绪状态之前
- 退出 (exit) 一个进程从系统中消失，系统正在回收它的资源 进程结束



#### 状态变迁
- NULL -> 创建：一个新进程被创建出来执行一个程序
- 创建->就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变成就绪态；等待 cpu的资源
- 就绪->运行：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行
- 运行->结束：进程完成/出错，操作系统开始回收资源
- 运行->就绪：时间片用完
- 运行->等待：请求某资源
- 等待->就绪：等待的事件出现了


## 挂起进程模型
与存储相关，虚拟存储 外存

处于挂起状态的进程映像在磁盘上，目的是减少进程占用内存量，提供更多内存给其他进程使用
图
**等待挂起状态**(Blocked-suspend):进程在外存并等待某事件的出现。在等待的基础上加了一个关于进程的位置的信息。
**就绪挂起状态**（ready-suspend）:进程在外存中（内存空间不够/进程优先级不高） ，但只要进入内存 可运行？存疑


### 与挂起相关的状态变换
#### 挂起：把一个进程从内存转到外存
- 等待到等待挂起
	- 没有进程处于就绪状态或就绪进程要求更多内存资源
- 就绪到就绪挂起
	- 高优先级等待进程（系统认为会很快就绪）和低优先级就绪进程 为了让高优先级进程进入后有足够空间
- 运行到就绪挂起 
	- 对抢先式分时系统，当有高优先级等待挂起进程因事件而进入到就绪挂起，那么当前运行的进程，，

三状态都会产生

#### 在外存时的状态转换
- 等待挂起到就绪挂起：当有等待挂起进程因相关事件出现

#### 激活 把一个进程外存到内存
- 就绪挂起到就绪
	- 没有就绪进程或挂起就绪进程优先级高于就绪进程
- 等待挂起到等待
	- 当一个进程释放足够内存，并有高优先级等待挂起进程


### 状态队列

由操作系统来维护一组队列，表示系统中所有进程的当前状态
不同队列表示不同状态：就绪 等待等
根据进程状态不同，进程PCB加入相应队列：进程状态变化时，它所在的PCB会从一个队列换到另一个

状态变迁 转换为 队列之间的进程的搬迁

## 线程的概念

一个进程内部更好的并发性。
### 为什么引入线程
应用 播放音频mp3,三个核心模块
1. 从Mp3音频文件中读取数据
2. 解压缩数据
3. 把解压缩的数据用声卡播放

单进程
```c
main()
{
	while(true)
	{
		Read();                      //I/O
 		Decompress();                //CPU
		Play();
	}
}
Read(){...}
Decompress(){...}
Play(){...}
```
问题：1. 播放出来的声音能否连贯？2. 各个函数之间不是并发执行，影响资源的使用效率

那么多进程？
存在的问题：1.进程之间如何通信？共享数据？ 但是多进程设计目标是隔离，矛盾。2. 系统开销大，进程切换，系统调用 ，在内核里绕一圈。


多线程的解决思路
在进程内部增加一类实体，满足以下特性：
1. 实体之间可以并发执行，多个指令指针。
2. 实体之间共享相同的地址空间，信息交流更方便。密切相关的一组执行流。
这种实体就是线程。


### 线程的概念
线程是进程的一部分，（剥离 并发 一个进程多个线程）描述指令流执行状态。它是进程中**指令执行流**的最小单元，是**CPU调度**的基本单位。
- 进程的资源分配角色：进程由一组相关资源构成，包括地址空间（代码段、数据段）、打开的文件等各种资源
- 线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态，独立的堆栈，函数调用 tcb:pc,sp,现场保护->寄存器

### 进程和线程的关系
线程=进程-共享资源 ；执行流的信息
线程的优点：
- 一个进程中可以同时存在多个线程
- 各个线程之间可以**并发**地执行
- 各个线程之间可以**共享**地址空间和文件等资源

线程的缺点：
没有了隔离
- 一个线程崩溃，会导致其所属进程的所有线程崩溃


### 不同操作系统对线程的支持
单进程系统：MS-DOS;
多进程系统：传统unix;
单进程多线程系统：psos,路由器，安全隔离要求低
多线程系统：现代unix


### 线程与进程的比较
- 进程是资源分配单位，线程是cpu调度单位
- 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈，保存信息少，切换速度快
- 线程具有就绪、等待和运行三种基本状态和状态间的转换关系
- 线程能减少并发执行的时间和空间开销
	- 同一进程内 线程的创建/终止/切换时间比进程段短
	- 共享也更方便，由于同一近臣的各线程间共享内存和文件资源，可不通过内核进行直接通信


## 线程的实现方式
1. 用户线程：操作系统没有，用户提出了需求 ，在用户空间实现，自己写函数库，POSIX Pthreads,Mach C-threads,Solaris threads
2. 内核线程：在内核中实现
3. 轻量级进程：在内核中实现，支持用户进程 ，lightweight process

### 用户线程
由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。内核空间只有进程控制块，图，内核感知多线程


**特征**：
- 不依赖操作系统的内核
	- 内核不了解 感知 用户线程的存在
	- 可用于不支持线程的多进程操作系统
- 在用户空间实现的线程机制
	- 每个进程有私有的线程控制块列表
	- TCB由线程库函数维护
- 同一进程内的用户线程切换速度快
	- 无需用户态/核心态切换
- 允许每个进程拥有自己的线程调度算法。应用开发者更了解

**不足**：
- 线程发起系统调用而阻塞时，则整个进程进入等待。内核并不知道上面是多线程
- 不支持基于线程的处理机抢占
	- 除非当前运行线程主动放弃，它所在进程的其他线程无法抢占CPU
- 只能按进程分配CPU时间
	- 多个线程进程中，每个线程的时间片较少


### 内核线程
由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理
线程控制块在内核里。
**特征**
- 由内核维护PCB和TCB
- 线程执行系统调用而被阻塞不影响其他线程
- 线程的创建、终止和切换相对较大
	- 通过系统调用/内核函数，在内核实现
- 以进程为单位进行CPU时间分配
	- 多线程的进程可获得更多CPU时间

### 轻权进程 solaris
内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。过于复杂。



### 用户线程与内核线程的对应关系
- 一对一 
- 多对一
- 多对多
