---
tags:
  - 内存
  - 复习
---
计算机： 计算能力 存储能力；

## 计算机体系结构 /内存层次 

> 哪里可以存数据；层次结构；管理存储介质



### 计算机体系结构
cpu:寄存器  高速缓存 ；
内存 ，最小访问单位 字节 8bit ；总线访问 32位 一次读4字节

### 内存层次结构

两级缓存 cpu 硬件作控制 ;缓存未命中，内存里面去读；内存 与外存 操作系统控制；
查找时间不同 由快到慢

### 操作系统的内存管理
要到达的效果： 存储控制单元把逻辑虚拟的地址空间 转换为 物理地址空间（内存+外村）
抽象：线性物理地址转变成逻辑地址空间
保护：每个进程只能访问自己的地址空间
共享：访问相同内存；
虚拟化：更大的地址空间 每个进程 


### 操作系统的内存管理方式

1. 重定位 relocation ：段地址+偏移
2. 分段 ssegmentation 不连续 数据 代码 堆栈  分成三块 一段的内容还是需要连续的
3. 分页 把内存分成基本的单位 ；盖楼 方砖 ，字节 粒度太细了；
4. 虚拟存储 



对硬件依赖程度高 这些方法；mmu,cpu


## 地址空间与地址生成

### 地址空间定义
物理地址空间 硬件支持；地址总线 32 位 
逻辑地址地址 在cpu运行的进程看到的地址；

### 逻辑地址生成
高级程序  编译 汇编 链接（放函数库） 程序加载（重定位）

### 地址生成时机

- 编译时：起始地址已知 功能机 写死的 不能加程序； 如果起始位置改变 必须重新编译
- 加载时 ：改成绝对地址；编译器生成可重定位的代码
- 执行时：执行到这条指令的时候 才知道访问的哪里；虚拟存储系统；执行时代码可移动

### 地址生成过程
- cpu : 
	- alu:需要逻辑地址的内存内容
	- mmu:进行逻辑地址和物理地址的转换 页表
	- cpu控制逻辑：给总线发送物理地址请求
- 内存： 
	- 发送物理地址内容给cpu 读
	- 或接收cpu数据到物理地址 写

- 操作系统
	- 页表的功能 建立映射。只是页表软件这里影响地址生成过程 其余都是硬件来做


### 地址检查


逻辑地址  段长度寄存器 与偏移量相比较；段基址寄存器；操作系统设置这两个寄存器大小



## 连续内存分配

如何找你要用的空闲分区如何处理不能利用的小的空闲分区


### 连续内存分配和内存碎片


- 连续内存分配：给进程分配一块不小于指定大小的连续的物理内存区域
- 空闲碎片：空闲内存不能利用
- 分类：外碎片：分配单元之间未被使用
	- 内碎片：分配给进程内部的未使用的内存；分配 单元 取整 512字节分


### 动态分区分配
分配一个进程指定大小可变的分区，分区的地址是连续的，当程序被加载执行时；

操作系统需要维护数据结构：所有进程的已分配分区；空闲分区
动态分区分配策略：
1. 最先匹配
2. 最佳匹配
3. 最差匹配 每次拿最大的


#### 最先匹配
分配N个字节，使用第一个可用的空间比n大的空闲块。
**实现**：
	空闲分区列表按地址顺序排序
	分配过程时，搜索第一个合适的分区
	释放分区时，检查是否可与临近的空闲分区合并
找和合并开销小；

**优点**：
	简单
	在高地址空间有大块空闲分区 在低地址 先 找
**缺点**
	外部碎片
	分配大块时较慢 前面外部碎片多了
每一次从头找，由低地址到高地址
#### 最佳匹配

分配N字节分区时，查找并使用不小于（比他大） n的最小空闲分区

**实现**：
	需要维护的数据结构，空闲列表按照大小排序
	分配时 查找一个合适的分区
	释放时 查找并且合并临近的空闲分区（地址临近 麻烦）
**优点**：
	大部分分配的尺寸较小时 效果很好
		避免大的空闲分区被拆分
		可减小外部碎片的大小
		相对简单
**缺点**：
剩下的边角料 太小了	。无法利用。
释放分区慢 复杂。

#### 最差匹配
思路： 分配N字节，使用尺寸最大的，不小于n
**实现**：
	空闲分区列表由达到小，
	分配时选最大的
	释放时，找临近的合并 方回到空闲列表，仍需要排序 找位置
**优点**：
	中等尺寸的分配较多时，效果最好
	剩的那块还可以找位置，避免出现太多的小碎片
**缺点**：
	释放分区较慢，释放后的合并是需要搜索的
	外部碎片
	容易破环大的空闲分区，因此后续难以分配大的分区

这几种出发点：空闲分区的列表按什么来排，在分配的时候它的查找开销，释放的时候合并开销以及合并结果放回到空闲分区列表找合适位置的开销。


## 碎片整理
已经把内存分区分配给了进程，新创建的进程需要内存空间 ，但是只有碎片了，怎么办
> 通过调整进程占用的分区位置来减少或避免分区碎片。
### 碎片紧凑
> 通过移动分配给进程的内存分区，以合并外部碎片

条件：所有的应用程序可动态重定位，可以搬动程序
什么时候移动？
开销

### 分区对换 swap in/out

刚才 一直在内存里面挪。

> 抢占回收 等待状态进程的分区 交换到外存里。

多个进程交替执行
但是开销大，内存与外存速度相差甚远
需要解决的问题：交换哪个哪些进程？

## 伙伴系统 
> 连续内存分配实例

### 基本做法，实现

整个可分配的分区大小 2的幂，
切一半 做比较，如果比2倍还大 继续切半。。。
数据结构：
	空闲块按大小和起始地址组织成二维数组
	初始状态：只有一个大小为2^u的空闲块
分配过程
	由小到大在空闲块数组中找最小的可用空闲块
	如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块。是不是比它的2倍大，如果不是 那么就是它了。
释放 合并过程
	把释放的块放入空闲块数组
	合并满足合并条件的空闲块：大小相同，地址相邻，相邻两块 低地址起始地址必须是2的倍数？
用于内核存储