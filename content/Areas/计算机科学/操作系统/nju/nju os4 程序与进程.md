- 程序是状态机的静态描述。描述了所有可能的程序状态。这也是为什么oj时测试样例过了，但是。。。a corner case。
- 程序运行起来，就成了进程。动态。
- ---
## 操作系统上的进程

进程：程序的运行时状态随时间的演进
进程号存储在哪里？一种可能，内存中的某个地方，只读的内存，指针指向它。另一种可能，进程号不存在进程里，而是存在os中，由os管理。系统调用特殊指令进程执行后进入os执行 `getpid()`


- 不停的追问。

### 两条公理

1. **机器永远是对的**
2. **未测代码永远是错的**

## 进程（状态机）管理API

### 进程管理系统调用

#### 一个直观想法
创建状态机：spawn孵化 （path,argv）路径和参数
销毁状态机：`_exit()` 为什么有下划线？被Libc占用了 。windows操作系统方式。符合软件工程规范。

#### unix答案
- **fork**:完整复制一份 everybit 分裂 。立即复制。汇编指令级的复制。寄存器和每一个字节的内存。唯一的区别是执行完fork后 原来的返回进程号，副本返回0.但是操作系统的状态的复制 ，打开的文件 浅拷贝。

### 进程树

`pstree`创建进程形成父子关系，父子关系连起来形成一棵树。共享变量


- 行缓冲，fflush 8行 6行hello 管道 #todo 

### 复位状态机
`execve(filename,argv[],envp[])`环境变量.计算机系统reset按钮。cpu reset,从0开始执行固件。
回到Main函数概念上。调用main。一般父进程waitpid.只复位了寄存器和内存能看到的状态，pid 和打开的文件 继承的 os , 所有操作系统内维护的权限都是继承的

- execve是**唯一**`strace ls &|vim ~`     `strace ./demo-1 &|less`   `strace echo hello &|vim ~`



复制状态机 ，复位状态机，销毁状态机。fork execve exit