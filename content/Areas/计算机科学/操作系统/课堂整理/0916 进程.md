---
title: 0916｜进程（课堂整理）
created: '2026-01-06'
tags:
  - 操作系统
  - 课堂整理
  - 进程
lectureDate: '2025-09-16'
---

相关：[[../课堂/os 0916 week2]]

本次会议围绕操作系统中进程的相关知识展开，包括进程的概念、状态模型、上下文切换、调度算法等内容，旨在帮助学员深入理解操作系统进程管理机制，内容如下：

## **进程概念引入**

### **操作系统发展与分时复用**

- 传统模式转变：表示现代化操作系统摒弃一人或一软件依次使用计算机的模式，采用分时复用手段，让每个用户以为自己程序连续运行，提升处理器利用率，其关键在于并发，利用程序对 CPU 和外设资源使用的交替性，合理安排程序运行顺序。

- 示例说明：通过安排两个程序交替运行，原本需 80 个时间单位顺序运行完的程序，45 个时间单位即可完成。

### **进程实现手段与抽象概念**

- 创建和读取存档：为实现程序的暂停和恢复，需解决将程序停下来并恢复的问题，关键是保存程序运行时寄存器的值作为存档，后续可读取存档继续执行。在编程上，让每个程序具备创建和读取存档功能，可通过面向对象编程创建基类实现，多数操作系统用 C 语言实现，继承默认 public。

- 进程定义：进程是运行在计算机上的程序，作为对象时基类为进程，它提供程序运行基本需求，如存储上下文（寄存器列表）和对应成员函数。通过记事本程序示例，解释了程序和进程的区别，程序是静态的，存于磁盘；进程是动态的，是程序运行实例，一个程序可创建多个进程，进程间默认互不感知，在操作系统帮助下可进行数据交互。

##  **进程管理的数据结构**

### **进程控制块（PCB）**

- 数据结构作用：指出实现操作系统进程管理需数据结构存储进程信息，常用的是进程控制块（PCB），其中包含进程 ID（PID）、上下文（context，存储寄存器列表）等信息，用于唯一标识进程和保存恢复执行状态。

- 代码示例：展示了操作系统课程实验代码中记录进程所需变量的组织结构，如 int PID 表示进程 ID，struct context 存储寄存器列表。

### **链表管理进程**

- 链表选择：由于不确定系统中进程数量，使用链表管理进程。考虑到删除操作的便利性，双链表是较好选择，虽存在信息冗余、操作复杂的问题，但在现代内存充足情况下，程序员编写代码的便利性更重要。

- 状态切换实现：进程状态切换需将运行进程的寄存器状态存入内存，读取待运行进程的存档并加载到寄存器，完成控制权转换。以 sleep 函数为例，解释了程序放弃 CPU 执行权的过程，操作系统会保存进程状态、设置定时器，在合适时机切换进程。还通过 switch to 函数代码，详细说明了进程上下文切换的具体实现。

## **进程状态与系统调用**

###  **进程状态分类与迁移**

- 状态分类：将进程状态分为运行态、就绪态和阻塞态，运行态进程可因系统调用变为阻塞态，因时钟中断或主动放弃变为就绪态；阻塞态进程在等待事件完成后变为就绪态；就绪态进程被选中后变为运行态。

- 状态机模型：通过有限状态机模型描述进程状态迁移，该模型简单且状态迁移有条件约束。nice 系统调用设计用于进程主动让渡资源，但实际很少被使用，因此引入时钟中断实现时间片轮转调度，确保进程公平使用 CPU。

### **系统调用与特权指令**

- 系统调用作用：为确保程序在不使用 CPU 时让出权利，引入系统调用（Syscall）。当程序需要使用 CPU 以外设备时，会调用系统调用，系统调用函数中内嵌 switch to 函数，实现进程控制权让渡。

- 特权指令与状态：计算机世界分为特权态和用户态，特权态 CPU 可执行特权指令和普通指令，用户态 CPU 只能执行普通指令。为防止用户绕过系统调用，将对打印机、屏幕等设备的控制指令设为特权指令，用户程序访问这些资源需通过操作系统。

## **进程状态模型与系统设计考量**

### **三状态与七状态模型**

- 模型介绍：介绍了进程的三状态（或五状态）和七状态模型，七状态模型在三状态基础上增加了就绪挂起和阻塞挂起状态，可实现笔记本电脑扣盖后进程挂起和恢复功能。

- 模型选择：不同系统根据需求和健壮性选择合适的进程状态模型，如 Linux 早期采用三状态或五状态模型，安卓早期进程状态模型简单，现代模型逐渐丰富。状态模型越复杂，功能越丰富，但维护代价和引入 bug 的风险也越高。

### **系统设计思考**

- 软件成长过程：强调软件和开发者都需要成长过程，操作系统从单进程模型发展到多进程分时复用模型，经历了不断完善的过程。

- 实验调整：今年将对操作系统实验进行细化调整，使实验与课程原理相对独立，鼓励学生在 AI 帮助下独立完成实验，并在实验中设置挑战。

## **上下文切换与体系结构**

### **上下文切换代价**

- 时间成本分析：指出进程上下文切换需将寄存器状态存入内存并读取，涉及多次内存操作，代价较高。以 CPU 视角看，与内存、硬盘、网络等设备交互时间长，如硬盘响应时间在 CPU 看来以月为单位，网络数据包传输时间相当于 CPU 的 19 年。

- 体系结构影响：不同体系结构（CISC 和 RISC）在上下文切换时表现不同，RISC 体系结构虽运行效率高，但寄存器多，上下文切换时需保存和恢复的内容多，不占优势。

###  **优化解决方案**

- 访存操作合并：为提高上下文切换速度，可将访存操作合并，如 arm 体系结构增加 store memory 和 load memory 指令，实现批量内存操作，优化上下文切换性能。

- 芯片设计考量：芯片设计者需了解用户应用场景，针对特定需求设计指令，如在 AI 领域，根据 Transformer 矩阵乘法、softmax 等操作特点，设计乘累加硬件加速器和阈值过滤硬件，提高运算速度。

## **进程调度算法**

### **调度算法的考量因素**

- 调度时机与方式：进程调度需考虑发起调度的时机，如调用 nice 函数、进程进入等待状态或退出时。调度方式分为抢占式和非抢占式，现代多数操作系统采用抢占式调度，可提升系统交互性，但部分对程序状态控制要求高的系统（如大型客机飞行控制系统、探月工程系统）采用非抢占式调度。

- 选择进程的条件：从就绪队列中选择进程运行时，需考虑多个指标，如处理器利用率、吞吐量、平均周转时间、等待时间、响应时间等。不同指标之间可能存在矛盾，如高吞吐和低延迟通常难以兼顾。

###  **经典调度算法及局限性**

- 先来先服务调度：该算法按任务提交顺序执行，优点是公平且实现简单，但长任务会导致短任务等待时间长，降低吞吐率。

- 短任务优先调度：优先执行短任务可提高单位时间内完成任务数量，但长任务可能得不到执行机会。该方法需程序员提前告知任务运行时间，实际应用中用户往往难以确定。目前这些经典调度算法已基本不再使用。

### **高吞吐与低延迟的矛盾及解决思路**

- 矛盾分析：高吞吐和低延迟在多数情况下相互矛盾，如班车运输吞吐率高但个体等待时间长，打车延迟低但运转效率低。在网络和计算系统中，也存在类似问题，如高吞吐网络可能延迟高，影响游戏体验。

- 解决思路：要实现高吞吐和低延迟兼容，需对数据是否需要低延迟请求进行标记，操作系统、网卡、交换机、路由器等设备需识别该标记并优先处理低延迟数据。近年来，系统调度器研究通常先定义重要指标，再在达成该指标的同时尽量减少对其他指标的影响。
