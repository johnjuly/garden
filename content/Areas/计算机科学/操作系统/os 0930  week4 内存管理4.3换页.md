
# review

进程调度模型与物理内存分布联系在一起：挂起；
覆盖技术，过于复杂。
硬件：mmu  地址：页号+偏移量
page:虚拟内存块；pageframe:物理内存块。

页表的维护：OS page索引 pageframe内容 页号与页框号对应关系。
物理页框由buddy system best fit等分配方案 分配空白页框

# 多级页表

32位 100万数组页表项。树的结构 巨大且稀疏。用时间换空间。
## case study

80386
从0开始每次分内存4k；低12位可以不要；
页表项占32位；
只存20位 ，低12位是0？4096对齐的位置。省下12位空间。
构建一颗b+树代替巨大的数组。


#待查 如何通过计算得到中间10位的数据？除法 取余数
查页表的问题；

## 页表存在哪里

快表先于cache;
TLB:页号：页框号；
	如何告诉是否命中；数据复制128分 ，都比较，在O（1）时间内，耗费空间，比较器


## 64位 反置页表


内存页框数量小于页表项

进程号+虚拟页
![[Pasted image 20250930142311.png]]
内哈希？外哈希？开放/**闭合**
被淘汰的技术。。。表的索引，物理的页框号；
为什么叫反置页表？
	原来的页表是用程序员使用的地址查物理内存的地址，每个程序的page对应一个页表项，现在变成每个page frame对应一项
反置页表有几个？
	全局使用一个
反置页表有什么问题？
	可扩展性如何？
		多进程？多处理器？
安全性如何？
反置页表仅在PowerPC的64位处理器中使用了一段时间，随后被废弃

## 现在的页表

intel有一个寄存器：MAXPHYADDR标注自己的寻址空间，

huge page:512个4096 页贴在一起，2MB 。缺页 难以忍受；减少查页表时间，提高tlb利用率。

## 置换算法

### 1 OPT

：预测未来；relay 一遍又一遍；


### 2 FIFO

硬件实现容易；4个锁存器；
异常现象：belady 分配的物理页面数增加，缺页次数反而升高。


### 3 LRU（时间）

维护一个栈；置换的页面是最长时间没有被引用的。被置换页面下溢。被访问栈顶。
![[Pasted image 20250930151954.png]]
不是每个程序具有局部性，线性扫描；看电影，读小说，旅行；有一部分具有局部性。
但是 ，难以实现 栈的结构。

### 4 最不常用算法 LFU



### 时钟置换算法 1bit计数 CLOCK

环形链表。清除access bit