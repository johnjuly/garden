简单 不涉及控制流 条件 分支 循环 没有branch指令
一行一行 顺序执行语句的翻译

小难点：数组的翻译
![[Pasted image 20251204203026.png]]左边与右边的区别是左边不再只是id 可以是 数组元素了L。可以做数组元素的访问。
看等号的右边 也可以是数组元素的引用 类似于 `a[1][2]=b[2][3]`

综合属性 自底向上 从叶子节点出发：
- E.code:中间代码
- E.addr:变量名，常量，与地址无关
例子：![[Pasted image 20251204203749.png]]
- top指的是符号表当前作用域的![[Pasted image 20251204203732.png]]
---



![[Pasted image 20251204204139.png]]
优化级别0 因为有load store.如果开了优化 ，那么这两条指令都会被删掉 只剩下return 0.


## 数组引用的中间代码翻译
两个地方碰到数组：
声明：`int a[2][3]` 
数组引用 ：`x=a[1][2],a[1][2]=x`右值 +左值

表达式不是处理声明，而是数组引用，与a的相关信息存储到符号表中。
核心是计算 `a[1][2]`相对于**数组基地址**a的**偏移地址**
计算对应的__宽度__当计算类型的时候
继承属性 往右边下面传递
综合属性 接受
`a[2]`两个小数组，`[3]`每个小数组里面元素有3![[Pasted image 20251204205515.png]]
声明语法的时候同时拿到了  类型信息和每一个类型对应的宽度信息。![[Pasted image 20251204205612.png]]

综合属性的计算右边的语义![[Pasted image 20251204205925.png]]
累乘与累加。递归。偏移地址的计算。![[Pasted image 20251204210443.png]]

---

### 对应llvm的实现
gep指令 hh 操作指针 不对内存进行计算。跟内存有关的操作只有load/store/alloca; 0 指向数组本身 当函数传递参数的时候需要。
后面的索引 一条一条脱去层。它会帮你计算。

:yum:
:smile:

