
## module模块


1. 层次关系：Module → Function → Block → Instruction → Operand

2. 容器类型：

- Module 使用 vector 存储多个函数

- Function 使用 map 通过 label 快速查找基本块

- Block 使用 deque 支持前后插入指令

1. 设计模式：

- 访问者模式：统一遍历接口

- 工厂模式：复用操作数对象

- 继承多态：指令类型统一管理
```
┌─────────────────────────────────────────────────────────────┐
│                      Module (ir_module)                     │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  globalVars: vector<GlbVarDeclInst*>                  │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │ │
│  │  │ @global_var1 │  │ @global_var2 │  │ @global_var3 │ │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘ │ │
│  └───────────────────────────────────────────────────────┘ │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  funcDecls: vector<FuncDeclInst*>                     │ │
│  │  ┌──────────────┐  ┌──────────────┐                  │ │
│  │  │ declare func1│  │ declare func2│  ...              │ │
│  │  └──────────────┘  └──────────────┘                  │ │
│  └───────────────────────────────────────────────────────┘ │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  functions: vector<Function*>                         │ │
│  │  ┌──────────────────────────────────────────────────┐ │ │
│  │  │            Function 1                            │ │ │
│  │  │  ┌────────────────────────────────────────────┐ │ │ │
│  │  │  │ funcDef: FuncDefInst*                      │ │ │ │
│  │  │  │ ┌──────────────────────────────────────┐ │ │ │ │
│  │  │  │ │ define i32 @func1(i32 %arg1, ...)    │ │ │ │ │
│  │  │  │ └──────────────────────────────────────┘ │ │ │ │
│  │  │  └────────────────────────────────────────────┘ │ │ │
│  │  │  ┌────────────────────────────────────────────┐ │ │ │
│  │  │  │ blocks: map<size_t, Block*>                │ │ │ │
│  │  │  │ ┌──────────┐  ┌──────────┐  ┌──────────┐ │ │ │ │
│  │  │  │ │ Block 0  │  │ Block 1  │  │ Block 2  │ │ │ │ │
│  │  │  │ └──────────┘  └──────────┘  └──────────┘ │ │ │ │
│  │  │  └────────────────────────────────────────────┘ │ │ │
│  │  └──────────────────────────────────────────────────┘ │ │
│  │  ┌──────────────────────────────────────────────────┐ │ │
│  │  │            Function 2                            │ │ │
│  │  │  ... (类似结构)                                  │ │ │
│  │  └──────────────────────────────────────────────────┘ │ │
│  └───────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```



### instructions
#### 大的分类
```
┌─────────────────────────────────────────────────────────────┐
│              Instruction 基类 (ir_instruction)              │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  opcode: Operator                                     │  │
│  │  comment: string                                      │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
         │
         ├─────────────────────────────────────────────────────┐
         │                                                     │
    ┌────▼────┐  ┌────▼────┐  ┌────▼────┐  ┌────▼────┐      │
    │ 内存操作 │  │ 算术运算 │  │ 控制流  │  │ 函数相关 │      │
    └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘      │
         │            │            │            │            │
    ┌────▼────┐  ┌────▼────┐  ┌────▼────┐  ┌────▼────┐      │
    │ LoadInst│  │Arithmetic│  │BrCondInst│  │CallInst │      │
    │StoreInst│  │Inst      │  │BrUncond  │  │RetInst  │      │
    │Alloca   │  │IcmpInst  │  │Inst      │  │FuncDecl │      │
    │Inst     │  │FcmpInst  │  │          │  │Inst     │      │
    └─────────┘  └──────────┘  └──────────┘  │FuncDef  │      │
                                              │Inst     │      │
    ┌────▼────┐  ┌────▼────┐                 └─────────┘      │
    │类型转换 │  │ 其他    │                                   │
    └────┬────┘  └────┬────┘                                   │
         │            │                                         │
    ┌────▼────┐  ┌────▼────┐                                   │
    │SI2FPInst│  │GEPInst  │                                   │
    │FP2SIInst│  │PhiInst  │                                   │
    │ZextInst │  │GlbVar   │                                   │
    └─────────┘  │DeclInst │                                   │
                 └─────────┘                                   │
                                                               │
┌──────────────────────────────────────────────────────────────┘
│
```
#### loadInst

有两个构造函数 ，分别对应加载普通类型和指针类型。


```
┌─────────────────────────────────────────────────────────────┐
│              设计思路的可视化                                │
│                                                              │
│  设计者的思考路径：                                           │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐ │
│  │  问题：如何表示 LLVM IR 的 load 指令？                │ │
│  │                                                      │ │
│  │  LLVM IR 格式：                                       │ │
│  │  %reg = load <type>, <type>* %ptr                   │ │
│  └──────────────────────────────────────────────────────┘ │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐ │
│  │  设计决策 1：需要哪些信息？                           │ │
│  │  • 数据类型（dt）                                     │ │
│  │  • 指针操作数（ptr）                                  │ │
│  │  • 结果操作数（res）                                  │ │
│  └──────────────────────────────────────────────────────┘ │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐ │
│  │  设计决策 2：指针类型怎么办？                         │ │
│  │                                                      │ │
│  │  发现：指针类型需要区分 int* 和 float*               │ │
│  │  → 需要额外的 ptrElemType                            │ │
│  └──────────────────────────────────────────────────────┘ │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐ │
│  │  设计决策 3：如何简化使用？                           │ │
│  │                                                      │ │
│  │  方案：                                               │ │
│  │  • 普通类型：不需要 ptrElemType（默认值即可）          │ │
│  │  • 指针类型：必须明确指定                             │ │
│  │  → 两个构造函数                                       │ │
│  └──────────────────────────────────────────────────────┘ │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐ │
│  │  最终设计：                                            │ │
│  │  ┌────────────────────────────────────────────────┐ │ │
│  │  │  LoadInst {                                    │ │ │
│  │  │      dt,              // 数据类型              │ │ │
│  │  │      ptrElemType,      // 指针元素类型（可选）   │ │ │
│  │  │      ptr,              // 指针操作数              │ │ │
│  │  │      res               // 结果操作数             │ │ │
│  │  │  }                                              │ │ │
│  │  └────────────────────────────────────────────────┘ │ │
│  └──────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

也牵涉到类型系统的设计，指针使用两个表示 而不是一个，灵活 易于扩展 ptrElemType + \*\*


#### allocainst 
它的作用：在栈上分配内存
- 所以ptrelemtype是用来支持指针类型的，类型系统！

```
│  │  ─────────────────────────────────────────────────── │   │
│  │                                                      │   │
│  │  int x;           →  %reg = alloca i32               │   │
│  │  float y;        →  %reg = alloca float              │   │
│  │  int arr[10];    →  %reg = alloca [10 x i32]         │   │
│  │  int arr[5][3];  →  %reg = alloca [5 x [3 x i32]]    │   │
│  │                                                      │   │
│  │  关键理解：                                           │   │
│  │  • alloca 在栈上分配空间                              │   │
│  │  • 返回指向分配空间的指针                              │   │
│  │  • 函数返回时自动释放   
```

#### glbvar inst

对于 数组的全局初始化 声明 
`initArrayGlb`三个分支，分支1：顶层优化 全0时直接返回zeroinitializer分支2：叶子节点，输出单个元素；分支3：递归处理，生成数组结构
分支1和分支2即递归终止条件

|分支|条件|例子|输出|
|---|---|---|---|
|分支1|dimDph == 0 且全0|{0,0,0}|zeroinitializer|
|分支2|beginPos == endPos|单个元素|i32 1|
|分支3|其他情况|多维数组|递归生成结构|

#### gep inst

get element pointer 数组/指针寻址。

`getelementptr <pointee type>, <pointee type>* <base>, <idxType> idx0, <idxType> idx1, ...`


---

在 int a\[2]\[3] 的例子里，你可以这样理解：

- %a 指向的是“一整个 2x3 的矩阵”

- 0 表示：从这个矩阵的起点开始（不是别的矩阵）

- 然后 i, j 再在矩阵内部移动
你看到的第一个 0，其实就是 idxs 里的第一个元素，语义就是“从这个数组整体的第 0 个位置开始算起”。

```cpp
int a[10];
int *p = &a[i];
```

gep:`%p = getelementptr [10 x i32], [10 x i32]* %a, i32 0, i32 %i`


### operand
整体
```
┌─────────────────────────────────────────────────────────────┐
│              Operand 基类 (ir_operand)                      │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  type: OperandType                                    │  │
│  │  toString(): string                                   │  │
│  │  getRegNum(): size_t                                  │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
         │
         ├──────────┬──────────┬──────────┬──────────┐
         │          │          │          │          │
    ┌────▼────┐ ┌──▼────┐ ┌──▼────┐ ┌──▼────┐ ┌───▼────┐
    │ Reg     │ │ Imme  │ │ Imme  │ │Global │ │ Label  │
    │ Operand │ │ I32   │ │ F32   │ │Operand│ │Operand │
    └────┬────┘ │Operand│ │Operand│ └───┬───┘ └───┬────┘
         │      └───┬───┘ └───┬───┘     │         │
         │          │          │         │         │
    ┌────▼────┐ ┌──▼────┐ ┌──▼────┐ ┌──▼────┐ ┌───▼────┐
    │%reg_1   │ │  42   │ │0x4040 │ │@var   │ │%Block0 │
    │%reg_2   │ │  -10  │ │0x3f80 │ │@func  │ │%Block1 │
    │%reg_3   │ │   0   │ │       │ │       │ │        │
    └─────────┘ └───────┘ └───────┘ └───────┘ └────────┘
```

寄存器，立即数（整数 浮点），全局变量名`@g` 基本块标签`%Block0` 。

#### operandfactory?
- 动机：对于相同的值（同一个立即数 同一个寄存器号 同一个全局名）全程序只创建一个对象，反复复用，统一在一个地方管理这些对象的生命周期。工厂+缓存 ；
- 把创建操作数的操作锁进了工厂类里面：子类的构造函数是private+friend 使用声明工厂类是friend, 构造函数为私有，普通代码不能new operand
- 缓存：map 值->指针 ,映射；查缓存：map.find
- 把所有operand 的创建/缓存/销毁都集中到一个类里


---
## printer
### 位置
- `module/*`定义IR结构和`tostring();`
- `visitor/printer/*`用visitor模式从module顶层一路走下去 把整个IR打印出来
### 目的
把ir打印成llvm ir文本。遍历+调用tostring 把结果写到ostream
### 调用流程
串成一条线就是：

1. 外面调用：module.accept(printer, os)（封装了一下 apply）。

2. visit(Module&)：

- 遍历函数声明 / 全局变量 / 函数定义，分别 apply(*this, ...)。

1. visit(Function&)：

- 打印 define ... 行，然后 { ... } 包裹所有基本块。

1. visit(Block&)：

- 打印 BlockX:，然后一行一行打印指令。

1. visit(某个 Inst&)：

- 直接调用该指令的 toString()
## codegen
