## introduction to semantic analysis

### review where we are

- lexical analysis
	- 从enforcing 语言定义的角度来看，词法分析的主要工作时检测输入字符串中那些不属于我们语言的那部分符号。detect inputs with illegal tokens
- parsing
	- 从判断这个程序是否格式正确或是否是有效程序的角度，检测所有语句中是否存在格式错误或没有解析树。detect inputs with ill-formed parse trees
- semantic analysis
	- last front end phase
	- catches all remaning errors 


- 将这三者考虑成过滤器，它们会逐步过滤掉越来越多的输入字符串，最后剩下的就是能够编译的有效程序了。流水线的最后一步。

### 原因 
- parsing cannot catch some errors
- some language constructs not context-free

### 它会做什么呢

对于cool,它会 check 六类检查
1. all identifiers are declared，同时检查作用域
2. types 主要功能

---
面向对象相关
1. inheritance relationships
2. classes defined only once
3. methods in a class defined only once
---

1. reserved identifiers are not misused 
and others...


the requirements depend on the language


## scope

### the motivating problem 

- *we want to*  match identifier declarations with uses
	- important static analysis step in most languages


### example

![[Pasted image 20251129165247.png]]
1. 使用错误
2. 没有用到y,没有看到x的定义

### idea

- the scope of an identifier is the portion of a program in which that identifier is accessible
- the same identifier may refer to different things in different parts of the program
	- different scopes for same name donot overlap
- an identifier may have restricted scope

- most languages have *static scope*
	- scope depends only on the program text,not run-time behavioe
- a few languages are *dynamically scoped*(lisp changed,snobol)
	- scope depends on execution of the program


### static scope的例子
![[Pasted image 20251129170035.png]]
使用most closely nested rule,so a variable binds to the definition that is most closely enclosing it of the same name.

![[Pasted image 20251129170213.png]]


![[Pasted image 20251129170250.png]]
![[Pasted image 20251129170327.png]]
bar 在定义之前使用
![[Pasted image 20251129170404.png]]
![[Pasted image 20251129170436.png]]![[Pasted image 20251129170450.png]]