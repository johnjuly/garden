
## 1
```yacc
PROGRAM:

STMT_LIST {

$$ = new Root($1);

parser.ast = $$;

}

| PROGRAM END {

YYACCEPT;

}

;
```
- PROGRAM: STMT_LIST { ... }：产生式，PROGRAM 可由 STMT_LIST 推导

- \$\$：当前非终结符的语义值

- $1, $2, ...：产生式右侧第1、2个符号的语义值

- { ... }：动作代码，在匹配时执行，用于构建 AST


- 第一条产生式 PROGRAM: STMT_LIST { ... }
- `$$ = new Root($1);`：把右侧第1个符号（STMT_LIST）的语义值 $1（一个语句节点列表）包装成根节点 Root，并赋给当前左侧非终结符 PROGRAM 的语义值 \$\$。

- `parser.ast = $$;`：把构造好的根节点保存到外部解析器对象里，便于解析结束后取出整棵 AST。

- 第二条产生式 PROGRAM: PROGRAM END { ... }

- YYACCEPT;：立即让解析器成功结束（通常用于读到“文件结束”或特定终止符时），相当于返回解析成功。
- 这段动作的核心作用：在完成语法归约时创建 AST 根节点并对外暴露，同时提供一个“读到 END 就结束”的快速收尾路径。

---
## 2
这段代码定义 STMT_LIST（语句列表）的语法规则，用于将多个语句收集到一个向量中。逐行解释：
```

STMT_LIST:
    STMT {
        $$ = new std::vector<StmtNode*>();
        if ($1) $$->push_back($1);
    }
    | STMT_LIST STMT {
        $$ = $1;
        if ($2) $$->push_back($2);
    }
    ;
```
单个语句也可以构成一个语句列表。
动作代码：
`$$=new std::vector<StmtNode*>();`创建一个空语句节点向量，作为STMT_LIST的语义值
含义：在已有语句列表后追加一个新语句，形成更长的列表（递归扩展）。

动作代码：

- $$ = $1;：复用已有的 STMT_LIST（$1），作为新的 STMT_LIST 的语义值。

- if ($2) $$->push_back($2);：如果新语句（$2）非空，将其追加到向量末尾。

## 3

```
CONTINUE_STMT:
    CONTINUE SEMICOLON {
        $$ = new ContinueStmt(@1.begin.line, @1.begin.column);
    }
    ;
```
`@locations`启用位置跟踪功能，让Bison自动 行列号 。`@1 `产生式右侧第一个符号的位置信息。


## 4 
```
FUNC_BODY:

LBRACE RBRACE {

$$ = nullptr;

}

| LBRACE STMT_LIST RBRACE {

if (!$2 || $2->empty())

{

$$ = nullptr;

delete $2;

}

else if ($2->size() == 1)

{

$$ = (*$2)[0];

delete $2;

}

else $$ = new BlockStmt($2, @1.begin.line, @1.begin.column);

}
```
- $2 是 STMT_LIST 的语义值，指针，类型为 std::vector<StmtNode*>*

- \[0] 是数组/向量下标访问，访问第一个元素

- size() 是 std::vector 的成员函数，返回元素数量


## 5 为什么使用entry 对于函数名字
将函数名字符串转换为符号标识对象，便于后续的符号管理和语义检查。
- 字符串不方便：比较慢，管理困难

- Entry 更方便：比较快，便于符号表管理

- 设计模式：单例模式，保证同一符号共享同一个 Entry 对象

那些token不是标识符，不需要做符号登记，也不需要靠名字去查找，只有真正的名字才需要转成entry这种全局唯一的符号条目，后续符号表，语义检查才有统一的引用和比较，。只有涉及到ident的地方才需要。

## 6 for 两个规则
`VAR_DECLARATION` `EXPR`
c/c++ 语言规范里的for循环文法`for(init;cond;step)`其中的init可以是声明或表达式，支持int i=0这种声明式初始化又支持i=0··这种普通表达式初始化。

## 6 for again 
`@3.begin.line`
`$3->line_num`
对象类型不同: @i是Bison提供的位置信息对象；、$指指向AST节点的指针，节点里自带位置信息字段。
- @i.xxx 用点号，是在访问 Bison 的位置对象（值语义）。

- $i->xxx 用箭头，是在访问 AST 指针节点的成员（指针语义）。

- 选 @i 还是 node->line_num，取决于你更想用“语法位置”还是“已有 AST 节点记录的位置”。


## 7 if 语句

`%prec THEN`比ELSE 优先级低。
优先级：
	移进(shift)：继续读取下一个token
	规约(reduce)：应用产生式规则

## 8 函数参数
`        dim->emplace_back(new LiteralExpr(-1, @3.begin.line, @3.begin.column));`
emplace_back:在向量末尾就地构造元素.直接构造，避免临时对象，push_back。手动创建向量并放入标记。


## 9 初始化 
数组列表初始化
源代码: int arr[3] = {1, 2, 3};
>[!example]
>{}
```
语法分析过程:
1. TYPE = int
2. LEFT_VAL_EXPR = arr[3] (LeftValExpr { entry="arr", indices=[LiteralExpr(3)] })
3. INITIALIZER_LIST 构建:
   - INITIALIZER = 1 (Initializer { init_val=LiteralExpr(1) })
   - INITIALIZER_LIST = [1]
   - INITIALIZER = 2 (Initializer { init_val=LiteralExpr(2) })
   - INITIALIZER_LIST = [1, 2]
   - INITIALIZER = 3 (Initializer { init_val=LiteralExpr(3) })
   - INITIALIZER_LIST = [1, 2, 3]
4. INITIALIZER = {1, 2, 3} (InitializerList { init_list=[1, 2, 3] })
5. VAR_DECLARATOR = arr[3] = {1,2,3}
6. VAR_DECLARATOR_LIST = [arr[3]]
7. VAR_DECLARATION = int [arr[3]]
8. VAR_DECL_STMT = int arr[3] = {1, 2, 3};
```

```
VarDeclStmt
    └─ VarDeclaration { type=int, isConst=false }
        └─ decls = [
            VarDeclarator {
                lval = LeftValExpr {
                    entry = "arr",
                    indices = [LiteralExpr(3)]
                },
                init = InitializerList {
                    init_list = [
                        Initializer { init_val = LiteralExpr(1) },
                        Initializer { init_val = LiteralExpr(2) },
                        Initializer { init_val = LiteralExpr(3) }
                    ]
                }
            }
        ]
```


## 10 函数调用

整体结构：
	无参/有参/特殊内置函数用于性能测试

sylib.h


## 11 表达式优先级
1. LOGICAL_OR_EXPR (||)

2. LOGICAL_AND_EXPR (&&)

3. EQUALITY_EXPR (\==, !=)

4. RELATIONAL_EXPR (<, <=, >, >=)

5. ADDSUB_EXPR (+, -)

6. MULDIV_EXPR (, /, %)

7. UNARY_EXPR (!, +, -)