 

## 1. nextToken() 返回类型和属性信息

`nextToken()` 返回 `YaccParser::symbol_type`（定义在 `yacc.h`）。

在 `scanner.h` 中：
```11:11:frontend/parser/scanner.h
#define YY_DECL FE::YaccParser::symbol_type FE::Scanner::nextToken()
```

在 `lexer.l` 中，通过 `YaccParser::make_XXX()` 创建并返回 token。例如：
- `YaccParser::make_INT_CONST(static_cast<int>(result), loc)`：创建整数常量 token，携带整数值和位置
- `YaccParser::make_IDENT(str, loc)`：创建标识符 token，携带字符串和位置
- `YaccParser::make_IF(loc)`：创建关键字 token，只携带位置

`symbol_type` 包含：
- token 类型（通过 `kind()` 获取）
- 语义值（通过 `value.as<T>()` 获取，如 `int`、`std::string`、`float` 等）
- 位置信息（`location`）

## 2. if-else 的移进-规约冲突处理

使用 `%prec THEN` 解决。在 `yacc.y` 中：

```274:281:frontend/parser/yacc.y
IF_STMT:
    IF LPAREN EXPR RPAREN STMT %prec THEN {
        $$ = new IfStmt($3, $5, nullptr, @1.begin.line, @1.begin.column);
    }
    | IF LPAREN EXPR RPAREN STMT ELSE STMT {
        $$ = new IfStmt($3, $5, $7, @1.begin.line, @1.begin.column);
    }
    ;
```

```133:136:frontend/parser/yacc.y
//THEN和ELSE用于处理if和else的移进-规约冲突
%precedence THEN
%precedence ELSE
// token 定义结束
```

示例：
```c
if (a) if (b) x = 1; else y = 2;
```

在解析到 `if (b) x = 1;` 后，遇到 `else` 时存在冲突：
- 移进：将 `else` 与内层 `if` 匹配
- 规约：将内层 `if` 规约为 `IF_STMT`

通过 `%prec THEN` 和优先级规则，bison 优先移进 `else`，确保 `else` 与最近的 `if` 匹配。

## 3. 语法树根节点

根节点类型为 `Root`，定义在 `ast.h`：

```36:49:frontend/ast/ast.h
    class Root : public Node
    {
      private:
        std::vector<StmtNode*>* stmts;

      public:
        Root(std::vector<StmtNode*>* stmts) : Node(-1, -1), stmts(stmts) {}
        virtual ~Root() override;

        virtual void accept(Visitor& visitor) override { visitor.visit(*this); }

        std::vector<StmtNode*>* getStmts() const { return stmts; }
    };
```

成员变量：
- `stmts`：指向语句节点向量的指针

子节点类型（继承自 `Node`）：
- `StmtNode`（语句节点）：`ExprStmt`、`VarDeclStmt`、`FuncDeclStmt`、`BlockStmt`、`ReturnStmt`、`WhileStmt`、`IfStmt`、`ForStmt`、`BreakStmt`、`ContinueStmt`
- `ExprNode`（表达式节点）：`LeftValExpr`、`LiteralExpr`、`UnaryExpr`、`BinaryExpr`、`CallExpr`、`CommaExpr`
- `DeclNode`（声明节点）：`VarDeclaration`、`VarDeclarator`、`ParamDeclarator`、`InitDecl` 等

所有子节点继承自 `Node`：

```23:34:frontend/ast/ast.h
    class Node
    {
      public:
        int      line_num;
        int      col_num;
        NodeAttr attr;  // 携带节点属性，是语法树标记的重点对象

        Node(int line_num = -1, int col_num = -1) : line_num(line_num), col_num(col_num), attr() {}
        virtual ~Node() = default;

        virtual void accept(Visitor& visitor) = 0;
    };
```

## 4. %token 和 %nterm 的含义

在 `yacc.y` 中：

- `%token`：定义终结符（token），对应词法分析器返回的符号。例如：
```70:84:frontend/parser/yacc.y
%token <int> INT_CONST
%token <long long> LL_CONST
%token <float> FLOAT_CONST
%token <std::string> STR_CONST ERR_TOKEN SLASH_COMMENT

%token <std::string> IDENT 

// TODO(Lab2)在这里添加 VOID Token
%token IF ELSE FOR WHILE CONTINUE BREAK SWITCH CASE GOTO DO RETURN CONST INT FLOAT VOID 
%token SEMICOLON COMMA LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE
%token END
%token PLUS MINUS STAR SLASH MOD
%token ASSIGN
%token EQ NE LT GT LE GE
%token AND OR NOT
```

- `%nterm`：定义非终结符，对应文法规则中的非终结符，可携带语义值类型。例如：
```86:129:frontend/parser/yacc.y
%nterm <FE::AST::Operator> UNARY_OP
%nterm <FE::AST::Type*> TYPE
%nterm <FE::AST::InitDecl*> INITIALIZER
%nterm <std::vector<FE::AST::InitDecl*>*> INITIALIZER_LIST
%nterm <FE::AST::VarDeclarator*> VAR_DECLARATOR
%nterm <std::vector<FE::AST::VarDeclarator*>*> VAR_DECLARATOR_LIST
%nterm <FE::AST::VarDeclaration*> VAR_DECLARATION
%nterm <FE::AST::ParamDeclarator*> PARAM_DECLARATOR
%nterm <std::vector<FE::AST::ParamDeclarator*>*> PARAM_DECLARATOR_LIST

%nterm <FE::AST::ExprNode*> LITERAL_EXPR
%nterm <FE::AST::ExprNode*> BASIC_EXPR
%nterm <FE::AST::ExprNode*> FUNC_CALL_EXPR
%nterm <FE::AST::ExprNode*> UNARY_EXPR
%nterm <FE::AST::ExprNode*> MULDIV_EXPR
%nterm <FE::AST::ExprNode*> ADDSUB_EXPR
%nterm <FE::AST::ExprNode*> RELATIONAL_EXPR
%nterm <FE::AST::ExprNode*> EQUALITY_EXPR
%nterm <FE::AST::ExprNode*> LOGICAL_AND_EXPR
%nterm <FE::AST::ExprNode*> LOGICAL_OR_EXPR
%nterm <FE::AST::ExprNode*> ASSIGN_EXPR
%nterm <FE::AST::ExprNode*> NOCOMMA_EXPR
%nterm <FE::AST::ExprNode*> EXPR
%nterm <std::vector<FE::AST::ExprNode*>*> EXPR_LIST

%nterm <FE::AST::ExprNode*> ARRAY_DIMENSION_EXPR
%nterm <std::vector<FE::AST::ExprNode*>*> ARRAY_DIMENSION_EXPR_LIST
%nterm <FE::AST::ExprNode*> LEFT_VAL_EXPR

%nterm <FE::AST::StmtNode*> EXPR_STMT
%nterm <FE::AST::StmtNode*> VAR_DECL_STMT
%nterm <FE::AST::StmtNode*> BLOCK_STMT
%nterm <FE::AST::StmtNode*> FUNC_DECL_STMT
%nterm <FE::AST::StmtNode*> RETURN_STMT
%nterm <FE::AST::StmtNode*> WHILE_STMT
%nterm <FE::AST::StmtNode*> IF_STMT
%nterm <FE::AST::StmtNode*> BREAK_STMT
%nterm <FE::AST::StmtNode*> CONTINUE_STMT
%nterm <FE::AST::StmtNode*> FOR_STMT
%nterm <FE::AST::StmtNode*> FUNC_BODY
%nterm <FE::AST::StmtNode*> STMT

%nterm <std::vector<FE::AST::StmtNode*>*> STMT_LIST
%nterm <FE::AST::Root*> PROGRAM
```

在上下文无关文法中：
- `%token` 对应终结符（词法单元）
- `%nterm` 对应非终结符（文法变量）

## 5. 处理“零次或多次”和“一次或多次”

使用递归文法规则处理。

零次或多次（如数组维度）：
```569:578:frontend/parser/yacc.y
ARRAY_DIMENSION_EXPR_LIST:
    ARRAY_DIMENSION_EXPR {
        $$ = new std::vector<ExprNode*>();
        $$->push_back($1);
    }
    | ARRAY_DIMENSION_EXPR_LIST ARRAY_DIMENSION_EXPR {
        $$ = $1;
        $$->push_back($2);
    }
    ;
```

一次或多次（如变量声明符列表）：
```358:367:frontend/parser/yacc.y
VAR_DECLARATOR_LIST:
    VAR_DECLARATOR {
        $$ = new std::vector<VarDeclarator*>();
        $$->push_back($1);
    }
    | VAR_DECLARATOR_LIST COMMA VAR_DECLARATOR {
        $$ = $1;
        $$->push_back($3);
    }
    ;
```

零次或多次（如参数列表）：
```334:346:frontend/parser/yacc.y
PARAM_DECLARATOR_LIST:
    /* empty */ {
        $$ = new std::vector<ParamDeclarator*>();
    }
    | PARAM_DECLARATOR {
        $$ = new std::vector<ParamDeclarator*>();
        $$->push_back($1);
    }
    | PARAM_DECLARATOR_LIST COMMA PARAM_DECLARATOR {
        $$ = $1;
        $$->push_back($3);
    }
    ;
```

## 6. 为什么使用不同优先级的表达式

避免二义性，正确表达运算符优先级和结合性。

如果使用单一 `EXPR`：
```
EXPR → EXPR ('+' | '-' | '*' | '/' | '&&' | '||' | ...) EXPR
```
会导致二义性，无法确定 `a + b * c` 的解析顺序。

使用分层表达式结构：
```441:514:frontend/parser/yacc.y
LOGICAL_OR_EXPR:
    LOGICAL_AND_EXPR {
        $$ = $1;
    }
    | LOGICAL_OR_EXPR OR LOGICAL_AND_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::OR, $1, $3, $1->line_num, $1->col_num);
    }
    ;

LOGICAL_AND_EXPR:
    EQUALITY_EXPR {
        $$ = $1;
    }
    | LOGICAL_AND_EXPR AND EQUALITY_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::AND, $1, $3, $1->line_num, $1->col_num);
    }
    ;

EQUALITY_EXPR:
    RELATIONAL_EXPR {
        $$ = $1;
    }
    | EQUALITY_EXPR EQ RELATIONAL_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::EQ, $1, $3, $1->line_num, $1->col_num);
    }
    | EQUALITY_EXPR NE RELATIONAL_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::NEQ, $1, $3, $1->line_num, $1->col_num);
    }
    ;

RELATIONAL_EXPR:
    ADDSUB_EXPR {
        $$ = $1;
    }
    | RELATIONAL_EXPR LT ADDSUB_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::LT, $1, $3, $1->line_num, $1->col_num);
    }
    | RELATIONAL_EXPR LE ADDSUB_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::LE, $1, $3, $1->line_num, $1->col_num);
    }
    | RELATIONAL_EXPR GT ADDSUB_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::GT, $1, $3, $1->line_num, $1->col_num);
    }
    | RELATIONAL_EXPR GE ADDSUB_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::GE, $1, $3, $1->line_num, $1->col_num);
    }
    ;

ADDSUB_EXPR:
    MULDIV_EXPR {
        $$ = $1;
    }
    | ADDSUB_EXPR PLUS MULDIV_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::ADD, $1, $3, $1->line_num, $1->col_num);
    }
    | ADDSUB_EXPR MINUS MULDIV_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::SUB, $1, $3, $1->line_num, $1->col_num);
    }
    ;

MULDIV_EXPR:
    UNARY_EXPR {
        $$ = $1;
    }
    | MULDIV_EXPR STAR UNARY_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::MUL, $1, $3, $1->line_num, $1->col_num);
    }
    | MULDIV_EXPR SLASH UNARY_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::DIV, $1, $3, $1->line_num, $1->col_num);
    }
    | MULDIV_EXPR MOD UNARY_EXPR {
        $$ = new BinaryExpr(FE::AST::Operator::MOD, $1, $3, $1->line_num, $1->col_num);
    }
    ;
```

优先级从低到高：`LOGICAL_OR_EXPR` < `LOGICAL_AND_EXPR` < `EQUALITY_EXPR` < `RELATIONAL_EXPR` < `ADDSUB_EXPR` < `MULDIV_EXPR` < `UNARY_EXPR`。递归结构确保 `*` 比 `+` 优先级更高，`&&` 比 `==` 优先级更高。

## 7. $$、$1、$2 和 @1 的含义

在 `yacc.y` 的语义动作中：

- `$$`：当前规则左部非终结符的语义值
- `$1`、`$2`、`$3` 等：规则右部第 1、2、3 个符号的语义值
- `@1`、`@2` 等：规则右部第 1、2 个符号的位置信息

示例：
```254:258:frontend/parser/yacc.y
FUNC_DECL_STMT:
    TYPE IDENT LPAREN PARAM_DECLARATOR_LIST RPAREN FUNC_BODY {
        Entry* entry = Entry::getEntry($2);
        $$ = new FuncDeclStmt($1, entry, $4, $6, @1.begin.line, @1.begin.column);
    }
    ;
```
- `$1`：`TYPE` 的语义值（`Type*`）
- `$2`：`IDENT` 的语义值（`std::string`）
- `$4`：`PARAM_DECLARATOR_LIST` 的语义值（`std::vector<ParamDeclarator*>*`）
- `$6`：`FUNC_BODY` 的语义值（`StmtNode*`）
- `$$`：`FUNC_DECL_STMT` 的语义值（`FuncDeclStmt*`）
- `@1.begin.line`、`@1.begin.column`：`TYPE` 的起始行号和列号

## 8. AST 打印

使用访问者模式打印 AST。

`ASTPrinter` 实现访问者接口：
```22:62:frontend/ast/visitor/printer/ast_printer.h
    class ASTPrinter : public Printer_t
    {
      public:
        // Basic AST nodes
        void visit(Root& node, std::ostream* os) override;

        // Declaration nodes
        void visit(Initializer& node, std::ostream* os) override;
        void visit(InitializerList& node, std::ostream* os) override;
        void visit(VarDeclarator& node, std::ostream* os) override;
        void visit(ParamDeclarator& node, std::ostream* os) override;
        void visit(VarDeclaration& node, std::ostream* os) override;

        // Expression nodes
        void visit(LeftValExpr& node, std::ostream* os) override;
        void visit(LiteralExpr& node, std::ostream* os) override;
        void visit(UnaryExpr& node, std::ostream* os) override;
        void visit(BinaryExpr& node, std::ostream* os) override;
        void visit(CallExpr& node, std::ostream* os) override;
        void visit(CommaExpr& node, std::ostream* os) override;

        // Statement nodes
        void visit(ExprStmt& node, std::ostream* os) override;
        void visit(FuncDeclStmt& node, std::ostream* os) override;
        void visit(VarDeclStmt& node, std::ostream* os) override;
        void visit(BlockStmt& node, std::ostream* os) override;
        void visit(ReturnStmt& node, std::ostream* os) override;
        void visit(WhileStmt& node, std::ostream* os) override;
        void visit(IfStmt& node, std::ostream* os) override;
        void visit(BreakStmt& node, std::ostream* os) override;
        void visit(ContinueStmt& node, std::ostream* os) override;
        void visit(ForStmt& node, std::ostream* os) override;

      private:
        void              emitPrefix(std::ostream& os) const;
        void              emitHeader(std::ostream& os, const std::string& text) const;
        void              pushLast(bool isLast);
        void              popLast();
        void              withChild(bool isLast, const std::function<void()>& fn);
        std::vector<bool> lastStack;
    };
```

从根节点开始打印：
```32:47:frontend/ast/visitor/printer/ast_printer.cpp
    void ASTPrinter::visit(Root& node, std::ostream* os)
    {

        lastStack.clear();
        *os << "ASTree\n";

        auto* stmts = node.getStmts();
        if (!stmts) return;

        size_t cnt = stmts->size();
        for (size_t i = 0; i < cnt; ++i)
        {
            if (!(*stmts)[i]) continue;
            withChild(i + 1 == cnt, [&]() { apply(*this, *(*stmts)[i], os); });
        }
    }
```

每个 AST 节点通过 `accept()` 调用对应的 `visit()`，递归打印整棵树，使用树形前缀（`|--`、``--`）表示层次关系。
1. 从根节点开始，apply(printer,ast,osptr)调用root::accept()调用visitor.visit(this,os);
2. 访问者分发：每个节点的accept()调用visitor.visit(thie,os)
3. 递归遍历：访问者打印当前节点，然后递归访问子节点
4. 前缀管理：laststack记录路径生成树形前缀
5. 输出格式：每个节点一行。


---

[MODE: RESEARCH]

检查语法树输出是否满足：能输出、无二义性、优先级正确。


[3 tools called]


检查语法树是否满足这三个条件：


[2 tools called]


检查编译时是否有冲突警告，并验证表达式优先级是否正确：


[2 tools called]


检查编译输出和优先级：


[2 tools called]


检查编译时是否有冲突警告，并验证优先级：


[2 tools called]


检查编译时是否有冲突警告，并验证优先级：


[1 tool called]


编译时无冲突警告。检查优先级是否正确。分析几个关键表达式：


[2 tools called]


分析语法树中的优先级是否正确。检查几个关键表达式：


[1 tool called]


根据语法树输出，总结如下：

## 检查结果

### 1. 能输出语法树
语法树已正确输出，结构完整，包含：
- 函数声明和定义
- 变量声明
- 表达式语句
- 控制流语句（if、while、return等）

### 2. 无二义性问题
编译时无冲突警告，说明：
- 已解决归约/归约冲突（NOCOMMA_EXPR规则）
- 已处理if-else的移进-规约冲突（使用%prec THEN和ELSE）

### 3. 优先级正确
从语法树验证几个关键表达式的优先级：

**表达式1：`5 - -/* This is */-/* a comment */-12 * 11 / 6 + -3`**
```
BinaryExpr + (加法在最后)
  ├─ BinaryExpr - (减法在中间)
  │   ├─ literal int: 5
  │   └─ BinaryExpr / (除法在乘法之后)
  │       ├─ BinaryExpr * (乘法在除法之前)
  │       │   ├─ UnaryExpr - (一元运算符优先级最高)
  │       │   └─ literal int: 11
  │       └─ literal int: 6
  └─ UnaryExpr - (一元运算符)
```
优先级正确：一元运算符 > 乘除 > 加减

**表达式2：`123 + +++55 - +-9961`**
```
BinaryExpr - (减法在最后)
  ├─ BinaryExpr + (加法在减法之前)
  │   ├─ literal int: 123
  │   └─ UnaryExpr + (一元运算符优先级最高)
  └─ UnaryExpr + (一元运算符)
```
优先级正确：一元运算符 > 加减

**表达式3：`1 && (f / -4 % 2 + 67) < 0 || (a - b) != 0 && (c + 2) % 2 != 0`**
```
BinaryExpr || (逻辑或在最外层)
  ├─ BinaryExpr && (逻辑与在逻辑或之前)
  │   ├─ literal int: 1
  │   └─ BinaryExpr < (关系运算符在逻辑与之前)
  │       ├─ BinaryExpr + (加法在关系运算符之前)
  │       └─ literal int: 0
  └─ BinaryExpr && (逻辑与)
      ├─ BinaryExpr != (不等号在逻辑与之前)
      └─ BinaryExpr !=
```
优先级正确：算术运算符 > 关系运算符 > 逻辑与 > 逻辑或

## 结论

语法树输出满足三个条件：
1. 能输出语法树
2. 无二义性问题（无冲突警告）
3. 优先级正确（表达式优先级符合预期）

语法分析器工作正常。

---
## 修复内容：

1. 修复了注释块未正确关闭的问题：在 yacc.y 文件第4行，将 / 改为 */，使注释块正确关闭。
    
2. 修复了归约/归约冲突：在 NOCOMMA_EXPR 规则中，移除了 LOGICAL_OR_EXPR 分支，只保留 ASSIGN_EXPR，因为 ASSIGN_EXPR 已经包含了 LOGICAL_OR_EXPR。
    
3. 添加了 void 关键字的识别：在 lexer.l 文件中添加了 "void" 关键字的识别规则。