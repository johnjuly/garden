## 1 apply函数 main.cpp


我先在代码库中搜索 `apply(` 的定义位置，并同时打开 `interfaces/frontend/ast_visitor.h` 以确认其函数模板签名与用法。
#设计模式
#访问者模式
[2 tools called]

[MODE: RESEARCH]

你关注的 `apply` 在这个项目里是“访问者模式”的一个泛型调用器。它的参数与用法可以直接从 `interfaces/ivisitor.h` 的定义看清楚。

- 在 `main.cpp` 的调用点如下，参数为：访问者实例、被访问的对象、额外参数（此处是输出流指针）：
```212:219:/home/petto/learning/compiler/NKU-Compiler2025/main.cpp
if (step == "-parser")
{
    FE::AST::ASTPrinter printer;
    std::ostream*       osPtr = outStream;
    apply(printer, *ast, osPtr);

    ret = 0;
    goto cleanup_ast;
}
```

- `apply` 的通用模板定义在 `interfaces/ivisitor.h`，核心签名是：
  - 第一个参数：访问者实例（如 `ASTPrinter`）
  - 第二个参数：被访问对象（如 `*ast`，它是 `FE::AST::Node` 的多态对象）
  - 后续可选参数：会被原样转发给访问者的 `visit` 方法（这里传了 `std::ostream*`）

具体重载如下（返回非 void 与返回 void 两种情况分别转发），关键行见下：
```c 297:311:/home/petto/learning/compiler/NKU-Compiler2025/interfaces/ivisitor.h
template <typename VisitorType, typename Visitable, typename... CallArgs,
    typename Return = typename std::remove_reference_t<VisitorType>::ReturnType,
    typename Set    = typename std::remove_reference_t<VisitorType>::VisitSetType>
static std::enable_if_t<!std::is_void_v<Return>, Return> apply(VisitorType& visitor, Visitable& vt, CallArgs&&... args)
{
    return Set::template apply<Return>(vt, visitor, std::forward<CallArgs>(args)...);
}

template <typename VisitorType, typename Visitable, typename... CallArgs,
    typename Return = typename std::remove_reference_t<VisitorType>::ReturnType,
    typename Set    = typename std::remove_reference_t<VisitorType>::VisitSetType>
static std::enable_if_t<std::is_void_v<Return>, void> apply(VisitorType& visitor, Visitable& vt, CallArgs&&... args)
{
    Set::template apply<Return>(vt, visitor, std::forward<CallArgs>(args)...);
}
```

要点小结（直观理解）：
- `apply(printer, *ast, osPtr)` 等价于调用 `ast->accept(某个包装过的访问者)`，再由多态分发到具体的 `visit(ConcreteNodeType&, std::ostream*)`。
- 访问者类型 `ASTPrinter` 在 `frontend/ast/visitor/printer/ast_printer.h` 中声明了对各节点的 `visit` 重载，并且其类型别名里定义了返回类型为 `void`、额外参数为 `std::ostream*`，因此这里 `apply` 会走“返回 void 的重载”。
- “后续参数会被转发给 visit”：这就是为什么 `apply` 第三个参数传 `osPtr`，对应 `visit` 的第二个形参。

如果你想进一步验证它如何层层向下遍历子节点，可看打印实现内部也反复用 `apply` 递归调用子节点的 `visit`，例如：
```36:43:/home/petto/learning/compiler/NKU-Compiler2025/frontend/ast/visitor/printer/expr_printer.cpp
withChild(true, [&]() { apply(*this, *node.expr, os); });
if (node.lhs) withChild(false, [&]() { apply(*this, *node.lhs, os); });
if (node.rhs) withChild(true, [&]() { apply(*this, *node.rhs, os); });
```

一句话回答你的原问题：
- `apply` 的参数是“访问者实例 + 被访问对象 + 可选传递给 visit 的实参”；在 `main.cpp` 中，它将 `ASTPrinter` 与 `*ast` 和 `outStream` 绑定，用访问者模式对 AST 根节点进行动态分派打印。


---
[MODE: RESEARCH]

你可以把“访问者模式”理解为：把“对一堆不同节点做的操作”从“节点类本身”里拿出来，集中放进一个“访问者”里，然后通过运行期的多态，自动根据实际节点类型调用对应的处理函数。这样做的好处是：不需要在每个地方写一堆 if/switch 判断类型，也不需要在节点类里塞很多不同阶段的逻辑（打印、检查、代码生成等），让结构更清晰。

### 它解决了什么问题
- 有一棵 AST，节点类型很多（`IfStmt`、`WhileStmt`、`BinaryExpr`…）。
- 你想对它做很多不同“操作”（打印、语义检查、生成 IR…），而且这些操作的参数/返回值可能还不一样。
- 访问者模式让你：
  - 在一个访问者类里为“每种节点类型”各写一个 `visit(NodeType&, ...)`；
  - 节点只需提供 `accept(visitor)`，把“自己”交给访问者处理；
  - 框架的 `apply(visitor, node, args...)` 会替你完成“传参与分派”，自动调到正确的重载。

### 项目里具体怎么用
- 在 `main.cpp` 打印 AST 的位置：
```212:219:/home/petto/learning/compiler/NKU-Compiler2025/main.cpp
if (step == "-parser")
{
    FE::AST::ASTPrinter printer;
    std::ostream*       osPtr = outStream;
    apply(printer, *ast, osPtr);

    ret = 0;
    goto cleanup_ast;
}
```
含义：用访问者 `ASTPrinter`，对 AST 根节点 `*ast` 进行访问；额外把 `osPtr`（输出流指针）一起传给每个 `visit`。

- `ASTPrinter` 对各节点类型分别实现了 `visit`，签名统一是返回 `void`，并接受一个 `std::ostream*` 参数：
```20:63:/home/petto/learning/compiler/NKU-Compiler2025/frontend/ast/visitor/printer/ast_printer.h
using Printer_t = Visitor_t<void, std::ostream*>;  // void return type, ostream pointer

class ASTPrinter : public Printer_t
{
  public:
    void visit(Root& node, std::ostream* os) override;
    // ...略...
    void visit(BinaryExpr& node, std::ostream* os) override;
    // ...略...
    void visit(IfStmt& node, std::ostream* os) override;
    // ...略...
};
```

- `apply` 的核心定义（自动把参数转发给对应的 `visit`，并做“返回 void / 非 void”的区分）：
```297:311:/home/petto/learning/compiler/NKU-Compiler2025/interfaces/ivisitor.h
template <typename VisitorType, typename Visitable, typename... CallArgs,
    typename Return = typename std::remove_reference_t<VisitorType>::ReturnType,
    typename Set    = typename std::remove_reference_t<VisitorType>::VisitSetType>
static std::enable_if_t<!std::is_void_v<Return>, Return> apply(VisitorType& visitor, Visitable& vt, CallArgs&&... args)
{
    return Set::template apply<Return>(vt, visitor, std::forward<CallArgs>(args)...);
}

template <typename VisitorType, typename Visitable, typename... CallArgs,
    typename Return = typename std::remove_reference_t<VisitorType>::ReturnType,
    typename Set    = typename std::remove_reference_t<VisitorType>::VisitSetType>
static std::enable_if_t<std::is_void_v<Return>, void> apply(VisitorType& visitor, Visitable& vt, CallArgs&&... args)
{
    Set::template apply<Return>(vt, visitor, std::forward<CallArgs>(args)...);
}
```
直白地说：`apply(printer, *ast, osPtr)` 会通过 `*ast` 的 `accept(...)` 做一次“二次分派”，最终调用到“实际节点类型”的 `visit(ConcreteNodeType&, std::ostream*)`。

- 打印器内部如何递归访问子节点？它也继续用 `apply`：
```36:43:/home/petto/learning/compiler/NKU-Compiler2025/frontend/ast/visitor/printer/expr_printer.cpp
withChild(true, [&]() { apply(*this, *node.expr, os); });
if (node.lhs) withChild(false, [&]() { apply(*this, *node.lhs, os); });
if (node.rhs) withChild(true, [&]() { apply(*this, *node.rhs, os); });
```

### 你要如何使用（最小心智模型）
- 第一步：定义一个访问者类，给每种节点写一个 `visit(该节点类型&, 可选参数...)`。返回类型可以是 `void` 或非 `void`，由你决定。
- 第二步：准备要访问的对象（如 AST 根）。
- 第三步：调用 `apply(访问者实例, 被访问对象, 额外参数...)`，它会自动把你传的额外参数转给每个 `visit`。

### 极简示例（演示“长什么样”）
```cpp
// 假设我们已有节点类型 A, B，并且访问者希望把结果打印到给定的 ostream
struct MyPrinter : FE::AST::Printer_t /* 即 Visitor_t<void, std::ostream*> */ {
    void visit(FE::AST::BinaryExpr& node, std::ostream* os) override {
        *os << "BinaryExpr\n";
        // 递归子节点
        if (node.lhs) apply(*this, *node.lhs, os);
        if (node.rhs) apply(*this, *node.rhs, os);
    }
    void visit(FE::AST::LiteralExpr& node, std::ostream* os) override {
        *os << "LiteralExpr\n";
    }
    // ...为其他节点继续实现 visit...
};

// 使用：
MyPrinter p;
std::ostream* os = &std::cout;
apply(p, *astRoot, os);  // 自动按实际节点类型调用对应的 visit
```

这样就不需要写：
- if/else 判断节点的真实类型；
- 手动做 `dynamic_cast`；
- 为每种操作都修改节点类本身的代码。

你只需记住一句话：`apply(访问者, 节点, 附带参数...)` 会“把参数传给 visit，并自动调到正确重载的 visit”。

- 小结
  - “访问者模式”=把“对各节点做什么”集中在访问者类里；节点只负责 `accept`。
  - `apply`=简化调用入口：自动分派、自动传参、自动处理返回类型。
  - 在本项目中：打印、语义检查、IR 生成都用它，写法一致，参数/返回因访问者而异。

## apply 函数的作用

apply 是一个模板函数，用于简化访问者模式的调用。它：

1. 自动推导访问者类型和返回值类型

2. 创建包装器，将参数传递给访问者的 visit 方法

3. 调用被访问对象的 accept 方法，触发访问者模式

在 main.cpp 中的调用：

apply(printer, *ast, osPtr);

等价于：

ast->accept(printer);  // 但 apply 提供了更灵活的接口，支持传递额外参数

apply 函数会自动：

- 识别 printer 的类型（ASTPrinter）

- 识别返回值类型（void，因为 Printer_t 定义为 Visitor_t<void, std::ostream*>）

- 创建适当的包装器

- 调用 ast->accept()，最终调用 printer.visit(*ast, osPtr)

这样，你不需要手动调用 accept，apply 会处理类型推导和分发。
## withchild
lambda表达式，[&]表示按引用捕获外部变量，因此lambda内部可以使用this:当前astprinter对象，当前语句节点`(*stmts)[i]`输出流指针os
```cpp
// 方式1：使用 Lambda 表达式（当前代码）

withChild(i + 1 == cnt, [&]() { apply(*this, *(*stmts)[i], os); });

  

// 方式2：显式指定捕获的变量

withChild(i + 1 == cnt, [this, &stmts, i, os]() {

apply(*this, *(*stmts)[i], os);

});
```

## 2 打印ast
我先快速打开相关的 AST 打印器与访问者接口源码，定位实现结构与调用流程。随后我会基于源码给出逐步讲解。


我已阅读打印器与访问者相关源码，下面按“数据结构 — 访问者接口 — 打印器实现 — 树形缩进渲染 — 遍历顺序与示例”的顺序，系统地说明 AST 打印是如何实现的。

### 抽象语法树节点结构与 accept
在 `frontend/ast/*.h` 中，每个 AST 节点都继承自 `Node`，并实现 `accept(Visitor&)`，用于双分派把自己交给具体的访问者处理。例如根节点 `Root`：

```32:49:/home/petto/learning/compiler/NKU-Compiler2025/frontend/ast/ast.h
class Root : public Node
{
  private:
    std::vector<StmtNode*>* stmts;

  public:
    Root(std::vector<StmtNode*>* stmts) : Node(-1, -1), stmts(stmts) {}
    virtual ~Root() override;

    virtual void accept(Visitor& visitor) override { visitor.visit(*this); }

    std::vector<StmtNode*>* getStmts() const { return stmts; }
};
```

表达式、语句、声明等具体节点同理，在各自头文件中定义（如 `expr.h`、`stmt.h`、`decl.h`），均提供 `accept`，用于将节点交给访问者。

### 访问者集合与多态分派
访问者框架定义在 `interfaces/ivisitor.h` 与 `interfaces/frontend/ast/ast_visitor.h`。其中 `ast_visitor.h` 将所有 AST 节点类型组合为一个类型集合 `TypeSet`，并基于此生成统一的访问者接口 `Visitor_t<Return, Args...>` 与类型擦除版 `Visitor`。

核心是通用的 `apply(visitor, node, args...)` 封装，它根据被访问对象的真实类型调用访问者的对应 `visit(T&)` 方法；打印器就是以 `void` 返回、`std::ostream*` 作为额外参数的访问者。

```39:46:/home/petto/learning/compiler/NKU-Compiler2025/interfaces/frontend/ast/ast_visitor.h
using TypeSet0 = type_list_utils::Concat_t<BasicTypeSet, DeclTypeSet>;
using TypeSet1 = type_list_utils::Concat_t<TypeSet0, ExprTypeSet>;
using TypeSet  = type_list_utils::Concat_t<TypeSet1, StmtTypeSet>;

template <typename... Ts>
using Visitor_t = VisitSetFrom<TypeSet>::Visitor<Ts...>;
using Visitor   = VisitSetFrom<TypeSet>::ErasedVisitor;
```

`apply` 的通用实现（模板）在 `ivisitor.h` 末尾，通过类型集封装实现“根据运行时类型分派到正确的 visit 重载”：



### ASTPrinter 的职责与 visit 声明
`ASTPrinter` 是一个具体访问者，继承自 `Visitor_t<void, std::ostream*>`，即“返回 void，额外携带一个输出流指针”的访问者。它为每种节点实现一个 `visit(NodeType&, std::ostream*)` 用于输出当前节点文本，并递归处理子节点。



### 树形缩进与行前缀的生成
打印器通过一个 `lastStack`（布尔栈）记录“当前层级是否为该层的最后一个子节点”。基于它生成 ASCII 树形结构的前缀：非末子用 `|--`，末子用 `` `-- ``，并用 `|   ` 或空格填充上层竖线。

```cpp
void ASTPrinter::emitPrefix(std::ostream& os) const
{
    if (lastStack.empty()) return;
    for (size_t i = 0; i + 1 < lastStack.size(); ++i) { os << (lastStack[i] ? "    " : "|   "); }
    os << (lastStack.back() ? "`-- " : "|-- ");
}

void ASTPrinter::emitHeader(std::ostream& os, const std::string& text) const
{
    emitPrefix(os);
    os << text << "\n";
}

void ASTPrinter::pushLast(bool isLast) { lastStack.push_back(isLast); }
void ASTPrinter::popLast()
{
    if (!lastStack.empty()) lastStack.pop_back();
}

void ASTPrinter::withChild(bool isLast, const std::function<void()>& fn)
{
    pushLast(isLast);
    fn();
    popLast();
}
```

- `withChild(isLast, fn)`：在进入一个子节点前先 `pushLast(isLast)`，执行打印/递归逻辑，完成后 `popLast()`；这样正确维护多层嵌套时的竖线与末端标记。
- `emitHeader`：打印当前节点的标
  #思考  #类比 ，32位地址空间想象成网球场大小，那么64位相当于欧洲大小  
  [MODE: RESEARCH]

查看相关代码文件以回答这些问题。


[6 tools called]


继续查看 AST 打印相关代码：


[4 tools called]


查看 AST 节点定义以完善答案：


[3 tools called]
题（行前缀 + 文本）。

### 遍历入口与总体流程
根节点 `visit(Root)` 清空缩进栈，先输出整棵树的表头 "ASTree"，然后对顶层语句列表逐个访问，并标注是否为最后一个以控制树枝形态。

```cpp
void ASTPrinter::visit(Root& node, std::ostream* os)
{

    lastStack.clear();
    *os << "ASTree\n";

    auto* stmts = node.getStmts();
    if (!stmts) return;

    size_t cnt = stmts->size();
    for (size_t i = 0; i < cnt; ++i)
    {
        if (!(*stmts)[i]) continue;
        withChild(i + 1 == cnt, [&]() { apply(*this, *(*stmts)[i], os); });
    }
}
```

可以看到遍历是“先打印当前，再递归访问子节点”的先序遍历，每一层使用 `withChild(isLast, ...)` 控制缩进。

### 各类节点的 visit 规则（选例）
以表达式 `BinaryExpr` 为例：输出操作符，然后分别递归访问左右子表达式，左不是末子、右是末子，这样树枝形状正确。

```cpp
void ASTPrinter::visit(BinaryExpr& node, std::ostream* os)
{
    emitHeader(*os, std::string("BinaryExpr ") + toString(node.op));
    if (node.lhs) withChild(false, [&]() { apply(*this, *node.lhs, os); });
    if (node.rhs) withChild(true, [&]() { apply(*this, *node.rhs, os); });
}
```

以 `IfStmt` 为例：先打印 If 头，然后为每个子部分（Condition/Then/Else）打印子标题，再递归访问其子树。子部分之间的末子标志根据是否为最后一个决定。

```cpp
void ASTPrinter::visit(IfStmt& node, std::ostream* os)
{

    emitHeader(*os, "IfStmt");
    if (node.cond)
    {
        withChild(false, [&]() {
            emitHeader(*os, "Condition:");
            withChild(true, [&]() { apply(*this, *node.cond, os); });
        });
    }
    if (node.thenStmt)
    {
        withChild(false, [&]() {
            emitHeader(*os, "Then:");
            withChild(true, [&]() { apply(*this, *node.thenStmt, os); });
        });
    }
    if (node.elseStmt)
    {
        withChild(true, [&]() {
            emitHeader(*os, "Else:");
            withChild(true, [&]() { apply(*this, *node.elseStmt, os); });
        });
    }
}
```

再看函数调用 `CallExpr`：先打印函数名，然后对每个实参打印形如 `Arg i:` 的中间层节点，再进入具体实参表达式。

```cpp
void ASTPrinter::visit(CallExpr& node, std::ostream* os)
{
    emitHeader(*os, std::string("Call ") + node.func->getName());
    if (!node.args) return;
    size_t cnt = node.args->size();
    for (size_t i = 0; i < cnt; ++i)
    {
        auto* arg = (*node.args)[i];
        if (!arg) continue;
        withChild(i + 1 == cnt, [&]() {
            std::string argHead = std::string("Arg ") + std::to_string(i) + ": ";
            emitHeader(*os, argHead);
            withChild(true, [&]() { apply(*this, *arg, os); });
        });
    }
}
```

变量声明集合 `VarDeclaration`：打印基类型，然后依次把每个 `VarDeclarator` 作为子节点继续打印。

```cpp
void ASTPrinter::visit(VarDeclaration& node, std::ostream* os)
{

    std::string head = std::string("VarDeclaration, BaseType: ") + node.type->toString();
    emitHeader(*os, head);
    if (!node.decls) return;
    size_t cnt = node.decls->size();
    for (size_t i = 0; i < cnt; ++i)
    {
        auto* d = (*node.decls)[i];
        if (!d) continue;
        withChild(i + 1 == cnt, [&]() { apply(*this, *d, os); });
    }
}
```

### 典型的调用方式
- 实际使用时，构造 `ASTPrinter printer;`，然后对根节点调用 `apply(printer, root, &os);`（或让根节点 `root.accept(printer)`，但这里打印器所有 `visit` 都要求 `std::ostream*` 参数，因此通常用 `apply` 传递该参数）。
- 遍历在各 `visit` 内部通过 `apply(*this, *child, os)` 继续向下分派。

### 小结
- 节点侧：每个 AST 节点实现 `accept(Visitor&)`，用于双分派。
- 接口侧：`ast_visitor.h` 汇总所有节点类型形成统一访问者集合；`ivisitor.h` 提供 `apply` 封装，实现基于类型集的安全分派。
- 打印器侧：`ASTPrinter` 继承特定签名的访问者基类，针对每种节点实现 `visit`，先输出一行标题，再对孩子节点用 `withChild(isLast, ...)` 包装递归调用，从而正确绘制 ASCII 树的分支与缩进。
- 缩进控制：`lastStack` 记录每层是否末子，`emitPrefix` 根据该栈渲染 `|--`、`` `-- `` 与竖线占位，确保树形结构清晰。

简要结论：
- 打印 AST 通过“访问者模式 + 树形缩进栈”实现，遍历是先序，分派由模板化 `apply` 完成。


---
### 调用流程
```
main.cpp:216
  apply(printer, *ast, osPtr)
    ↓
ivisitor.h:308 (全局 apply)
  Set::template apply<Return>(vt, visitor, args...)
    ↓
ivisitor.h:265 (VisitSet::apply)
  创建 VisitorWrapperV 包装器
  vt.accept(wrapper)  // 即 ast->accept(wrapper)
    ↓
ast.h:46 (Root::accept)
  visitor.visit(*this)  // 即 wrapper.visit(root)
    ↓
ivisitor.h 内部 (包装器分发)
  printer.visit(root, osPtr)
    ↓
ast_printer.cpp:32 (ASTPrinter::visit(Root&))
  输出 "ASTree\n"
  遍历 stmts，对每个子节点：
    apply(*this, *stmt, os)  // 递归
      ↓
    [重复上述流程，访问 VarDeclStmt, FuncDeclStmt 等]
      ↓
    stmt_printer.cpp / expr_printer.cpp / decl_printer.cpp
      打印节点信息，继续递归访问子节点
```
1. 双重分发：apply->accept->visit,通过包装器实现类型分发
2. 递归遍历：每个visit方法打印当前节点后，递归调用apply访问子节点
3. 参数传递：osptr通过包装器传递到所有visit方法


## emitprefix函数逻辑
laststack `std::vector<bool>`记录从根到当前节点路径上，每一层是否为最后一个子节点。
```cpp
void ASTPrinter::emitPrefix(std::ostream& os) const

{

if (lastStack.empty()) return;

for (size_t i = 0; i + 1 < lastStack.size(); ++i) { os << (lastStack[i] ? " " : "| "); }

os << (lastStack.back() ? "`-- " : "|-- ");

}

```

- 生成中间层前缀，遍历除最后一层外的所有层，`lastStack[i]==true`:输出4个空格；`lastStack[i]==false`:输出`"|"`竖线+3个空格；
- 生成最后一层前缀，true:输出反引号+两个横线+空格；false:输出竖线+3个空格
- 空栈，即根节点。不需要前缀。直接返回。