#!/usr/bin/env node
const fs = require("fs")
const path = require("path")

const publicDir = path.resolve(__dirname, "..", "public")
const contentIndex = path.resolve(__dirname, "..", "content", "index.md")

function walk(dir, base = "") {
  const entries = fs.readdirSync(dir, { withFileTypes: true })
  const files = []
  for (const e of entries) {
    const rel = path.posix.join(base, e.name)
    const full = path.join(dir, e.name)
    if (e.isDirectory()) {
      // include directory index if exists
      files.push({ type: "dir", name: e.name, rel, full })
      files.push(...walk(full, rel))
    } else if (e.isFile()) {
      files.push({ type: "file", name: e.name, rel, full })
    }
  }
  return files
}

function groupByExtension(items) {
  const groups = {}
  for (const it of items) {
    if (it.type !== "file") continue
    const ext = path.extname(it.name).toLowerCase() || "(noext)"
    if (!groups[ext]) groups[ext] = []
    groups[ext].push(it)
  }
  return groups
}

function safeUrl(rel) {
  // convert path to url with encodeURI per segment
  return "/" + rel.split(path.sep).map(encodeURIComponent).join("/")
}

function titleForFile(name) {
  // strip extension
  return name.replace(/\.[^.]+$/, "")
}

function generateMarkdown() {
  if (!fs.existsSync(publicDir)) {
    console.error("public/ directory not found at", publicDir)
    process.exit(1)
  }

  const items = walk(publicDir, "")
  const files = items.filter((i) => i.type === "file")
  const dirs = items.filter((i) => i.type === "dir")

  const groups = groupByExtension(items)

  const lines = []
  lines.push("---")
  lines.push("title: 自动生成的索引")
  lines.push("---")
  lines.push("")
  lines.push("Below are quick-jump links grouped by file type and directory.")
  lines.push("")
  lines.push("## 快速目录")
  lines.push("")
  lines.push("- [按文件类型](#by-type)")
  lines.push("- [按目录](#by-directory)")
  lines.push("")
  lines.push("---")
  lines.push("")

  // By type
  lines.push("## 按文件类型")
  lines.push("")

  const exts = Object.keys(groups).sort()
  for (const ext of exts) {
    const list = groups[ext].sort((a, b) => a.rel.localeCompare(b.rel))
    lines.push(`### ${ext}`)
    lines.push("")
    for (const f of list) {
      const url = safeUrl(f.rel)
      const title = titleForFile(f.name)
      lines.push(`- [${title}](${url}) — \\${f.rel}`)
    }
    lines.push("")
  }

  // By directory
  lines.push("---")
  lines.push("")
  lines.push("## 按目录")
  lines.push("")

  // collect directories with index.html or listing
  const dirMap = new Map()
  for (const it of items) {
    if (it.type === "file") {
      const dir = path.posix.dirname(it.rel)
      if (!dirMap.has(dir)) dirMap.set(dir, [])
      dirMap.get(dir).push(it)
    }
  }

  const dirsSorted = Array.from(dirMap.keys()).sort()
  for (const d of dirsSorted) {
    const display = d === "." || d === "" ? "/ (root)" : `/${d}`
    lines.push(`### ${display}`)
    lines.push("")
    const list = dirMap.get(d).sort((a, b) => a.name.localeCompare(b.name))
    for (const f of list) {
      const url = safeUrl(f.rel)
      lines.push(`- [${f.name}](${url})`)
    }
    lines.push("")
  }

  lines.push("---")
  lines.push("")
  lines.push("_This file was auto-generated by `scripts/generate-index.js`._")

  return lines.join("\n")
}

try {
  const md = generateMarkdown()
  fs.writeFileSync(contentIndex, md, "utf8")
  console.log("Wrote", contentIndex)
} catch (err) {
  console.error(err)
  process.exit(1)
}
